;	Static Name Aliases
;
;	$S422_bNoModeSet	EQU	bNoModeSet
	TITLE   video.c
	.286p
	.287
INCLUDELIB      SLIBCE
INCLUDELIB	OLDNAMES.LIB
_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT  BYTE PUBLIC 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT  BYTE PUBLIC 'DEBTYP'
$$TYPES	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
EXTRN	__aNulmul:NEAR
EXTRN	_printf:NEAR
EXTRN	_sscanf:NEAR
EXTRN	_BootArgs:BYTE
_DATA      SEGMENT
$S422_bNoModeSet	DW	00H
$SG502	DB	'N:',  00H
$SG503	DB	'n:',  00H
$SG504	DB	'%dx%dx%d:%dx%d',  00H
$SG510	DB	'ERROR: The physical screen dimensions (PX & PY) should be la'
	DB	'rger than the',  0aH, '       display resolution chosen. Thi'
	DB	's option is used to simulate a ',  0aH, '       smaller draw'
	DB	'ing area on a larger display.',  0aH,  00H
$SG512	DB	'%dx%dx%d:%dx%d',  00H
$SG521	DB	'ERROR: The physical screen dimensions (PX & PY) should be la'
	DB	'rger than the',  0aH, '       display resolution chosen.  Th'
	DB	'is option is used to simulate a ',  0aH, '       smaller dra'
	DB	'wing area on a larger display.',  0aH,  00H
_DATA      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	PUBLIC	_mode320x200x256
_mode320x200x256	PROC NEAR
;|*** //
;|*** // Copyright (c) Microsoft Corporation.  All rights reserved.
;|*** //
;|*** //
;|*** // Use of this sample source code is subject to the terms of the Microsoft
;|*** // license agreement under which you licensed this sample source code. If
;|*** // you did not accept the terms of the license agreement, you are not
;|*** // authorized to use this sample source code. For the terms of the license,
;|*** // please see the license agreement between you and Microsoft or, if applicable,
;|*** // see the LICENSE.RTF on your install media or the root of your tools installation.
;|*** // THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
;|*** //
;|*** 
;|*** /*++
;|*** 
;|*** THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
;|*** ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
;|*** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
;|*** PARTICULAR PURPOSE.
;|*** 
;|*** Module Name:    video.c
;|*** 
;|*** Abstract:
;|*** 
;|*** Functions:
;|*** 
;|*** 
;|*** Notes:
;|*** 
;|*** --*/
;|*** 
;|*** 
;|*** #include <stdio.h>
;|*** #include <stdlib.h>
;|*** #include <string.h>
;|*** 
;|*** #include "loadcepc.h"
;|*** #include "video.h"
;|*** #include "bootarg.h"
;|*** 
;|*** extern  BOOT_ARGS BootArgs;
;|*** 
;|*** static  BOOL    bNoModeSet = FALSE;
;|*** 
;|*** 
;|*** void mode320x200x256( void )
;|*** {
; Line 47
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
;|***     // Put the display into 320x200x256 colour mode and clear it
;|*** 
;|***     __asm
;|***     {
;|***         mov     ah, 0       ; Set video mode
; Line 52
	*** 000003	b4 00 			mov	ah,0
;|***         mov     al, 013h    ; 320x200x256 and clear screen
; Line 53
	*** 000005	b0 13 			mov	al,19	;0013H
;|***         int     10h         ; set mode 13
; Line 54
	*** 000007	cd 10 			int	16	;0010H
;|***     }
; Line 55
;|*** }
; Line 56
	*** 000009	c9 			leave	
	*** 00000a	c3 			ret	
	*** 00000b	90 			nop	

_mode320x200x256	ENDP
	PUBLIC	_isVesaSupported
_isVesaSupported	PROC NEAR
;|*** 
;|*** 
;|*** int isVesaSupported( void )
;|*** {
; Line 60
	*** 00000c	c8 04 02 00 		enter	516,0
	*** 000010	57 			push	di
;	vesaInfo = -512
;	pVesaInfo = -516
;|***     VESA_GENERAL_INFO   vesaInfo, far *pVesaInfo = &vesaInfo;
; Line 61
	*** 000011	8d 86 00 fe 		lea	ax,WORD PTR [bp-512]	;vesaInfo
	*** 000015	89 86 fc fd 		mov	WORD PTR [bp-516],ax	;pVesaInfo
	*** 000019	8c 96 fe fd 		mov	WORD PTR [bp-514],ss
;|*** 
;|***     __asm
;|***     {
;|***         mov     ax, 04F00h      ; Get VESA info
; Line 65
	*** 00001d	b8 00 4f 		mov	ax,20224	;4f00H
;|***         les     di, pVesaInfo   ; Pointer to info buffer
; Line 66
	*** 000020	c4 be fc fd 		les	di,DWORD PTR [bp-516]	;pVesaInfo
;|***         int     10h             ; check for VESA
; Line 67
	*** 000024	cd 10 			int	16	;0010H
;|*** 
;|***         cmp     ax, 0004Fh      ; Was it successful?
; Line 69
	*** 000026	3d 4f 00 		cmp	ax,79	;004fH
;|***         jne     noVesa
; Line 70
	*** 000029	75 07 			jne	$noVesa429
;|***     }
; Line 71
;|***     return TRUE;
; Line 72
	*** 00002b	b8 01 00 		mov	ax,1
	*** 00002e	5f 			pop	di
	*** 00002f	c9 			leave	
	*** 000030	c3 			ret	
	*** 000031	90 			nop	
;|*** 
;|*** noVesa:
; Line 74
					$noVesa429:
;|*** 
;|***     return FALSE;
; Line 76
	*** 000032	33 c0 			xor	ax,ax
;|*** }
; Line 77
	*** 000034	5f 			pop	di
	*** 000035	c9 			leave	
	*** 000036	c3 			ret	
	*** 000037	90 			nop	

_isVesaSupported	ENDP
	PUBLIC	_setVesaMode
_setVesaMode	PROC NEAR
;|*** 
;|*** 
;|*** int setVesaMode( int vesaMode, int scanLength )
;|*** {
; Line 81
	*** 000038	55 			push	bp
	*** 000039	8b ec 			mov	bp,sp
;	scanLength = 6
;	vesaMode = 4
;|*** 	//printf( "setVesaMode( %d, %d\n", vesaMode, scanLength );
;|*** 
;|***     __asm
;|***     {
;|***         mov     ax, 04F02h      ; VESA Set mode
; Line 86
	*** 00003b	b8 02 4f 		mov	ax,20226	;4f02H
;|***         mov     bx, vesaMode    ; Set given VESA Mode
; Line 87
	*** 00003e	8b 5e 04 		mov	bx,WORD PTR [bp+4]	;vesaMode
;|***         int     10h             ;
; Line 88
	*** 000041	cd 10 			int	16	;0010H
;|*** 
;|***         cmp     ax, 0004Fh      ; Was it successful?
; Line 90
	*** 000043	3d 4f 00 		cmp	ax,79	;004fH
;|***         jne     failed          ;
; Line 91
	*** 000046	75 16 			jne	$failed436
;|*** 
;|***         mov     cx, scanLength  ; Set so banks are an integral number lines
; Line 93
	*** 000048	8b 4e 06 		mov	cx,WORD PTR [bp+6]	;scanLength
;|***         jcxz    finished        ; if no scanLength requested, just exit
; Line 94
	*** 00004b	e3 0c 			jcxz	$finished437
;|***         mov     ax, 04F06h      ; VESA Set logical scan line length
; Line 95
	*** 00004d	b8 06 4f 		mov	ax,20230	;4f06H
;|***         mov     bl, 0           ;
; Line 96
	*** 000050	b3 00 			mov	bl,0
;|***         int     10h             ; set VESA scan length
; Line 97
	*** 000052	cd 10 			int	16	;0010H
;|*** 
;|***         cmp     ax, 0004Fh      ; Was it successful?
; Line 99
	*** 000054	3d 4f 00 		cmp	ax,79	;004fH
;|***         jne     failed          ;
; Line 100
	*** 000057	75 05 			jne	$failed436
;|***     }
; Line 101
;|*** 
;|*** finished:
; Line 103
					$finished437:
;|***     return TRUE;
; Line 104
	*** 000059	b8 01 00 		mov	ax,1
	*** 00005c	c9 			leave	
	*** 00005d	c3 			ret	
;|*** 
;|*** failed:
; Line 106
					$failed436:
;|***     return FALSE;
; Line 107
	*** 00005e	33 c0 			xor	ax,ax
;|*** }
; Line 108
	*** 000060	c9 			leave	
	*** 000061	c3 			ret	

_setVesaMode	ENDP
	PUBLIC	_SetVideoMode
_SetVideoMode	PROC NEAR
;|*** 
;|*** /* 
;|*** ** SetVideoMode: maps from the user input 0-X to a VESA mode
;|*** **
;|*** ** User  VESA MODE
;|*** ** Input
;|*** ** 0     320x200x256    default mode, should work on any video card with 64K 
;|*** **                      memory.
;|*** ** 1     480x240x256    non-standard VGA resolution, emulated in a 640x480 
;|*** **                      window.
;|*** ** 2     640x480x256
;|*** ** 3     800x600x256
;|*** ** 4     1024x768x256
;|*** ** 5     320x240x256    non-standard VGA resolution, emulated in a 640x480 
;|*** **                      window.
;|*** ** 6     208x240x256
;|*** */
;|*** 
;|*** UCHAR SetVideoMode( int desiredMode )
;|*** {
; Line 128
	*** 000062	55 			push	bp
	*** 000063	8b ec 			mov	bp,sp
;	desiredMode = 4
;	register dx = vesaMode
;	register cx = scanLength
;|***     int     vesaMode = 0;
;|***     int     scanLength;
;|*** 
;|***     // if user requested to skip the mode set, just pass bootargs
;|*** 
;|***     if( bNoModeSet )                                
; Line 134
	*** 000065	83 3e 00 00 00 		cmp	WORD PTR $S422_bNoModeSet,0
	*** 00006a	74 04 			je	$I444
;|***     {
;|***         return( 0xFF );     // force caller to leave bootargs vars alone
; Line 136
					$L530:
	*** 00006c	b0 ff 			mov	al,255	;00ffH
	*** 00006e	c9 			leave	
	*** 00006f	c3 			ret	
;|***     }
;|*** 
;|***     // In the default mode, there is no need to bank switch the card 
;|***     // since only 64K required VESA is NOT required for this mode.
;|*** 
;|***     if( desiredMode == 0 )
; Line 142
					$I444:
	*** 000070	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;desiredMode
	*** 000074	74 5c 			je	$I446
;|***     {
;|***         mode320x200x256();
;|***         return( 0 );
;|***     }
;|*** 
;|***     // If VESA is supported use VESA to put the 
;|***     // video card into the appropriate mode.
;|*** 
;|***     if( isVesaSupported() )
; Line 151
	*** 000076	e8 93 ff 		call	_isVesaSupported
	*** 000079	0b c0 			or	ax,ax
	*** 00007b	74 55 			je	$I446
;|***     {
;|***         switch( desiredMode )
; Line 153
	*** 00007d	8b 46 04 		mov	ax,WORD PTR [bp+4]	;desiredMode
;|***         {
;|***         case 0x01:   // 480x240x256 is emulated in a partial 640x480x256 screen 
;|***         case 0x02:
;|***         case 0x05:   // 240x320x256 is emulated in a partial 640x480x256 screen 
;|***         case 0x06:   // 208x240x256 is emulated in a partial 640x480x256 screen 
;|*** 
;|***             scanLength = VESASCANLENGTH1024;    // scan length for this mode 
;|***             vesaMode = VESAMODE640x480x256;     // VESA Mode 101 640x480x256 
;|***             break;
;|*** 
;|***         case 0x03:
;|*** 
;|***             scanLength = VESASCANLENGTH1024;    // scan length for this mode 
;|***             vesaMode = VESAMODE800x600x256;     // VESA Mode 103 800x600x256
;|***             break;
;|*** 
;|***         case 0x04:
;|*** 
;|***             scanLength = VESASCANLENGTH1024;    // scan length for this mode 
;|***             vesaMode = VESAMODE1024x768x256;    // VESA Mode 105 1024x768x256 
;|***             break;
;|*** 
;|***         default:    
;|***         
;|***             // VESA mode value was passed in - use directly 
;|*** 
;|***             vesaMode = desiredMode;   /* use passed in mode value */
;|***             vesaMode |= 0x4000;       /* ask for linear/flat framebuffer mode */
;|***             scanLength = 0;           /* use mode default scan length */
;|***             break;
;|***         }
; Line 184
	*** 000080	48 			dec	ax
	*** 000081	3d 05 00 		cmp	ax,5
	*** 000084	77 14 			ja	$SD454
	*** 000086	03 c0 			add	ax,ax
	*** 000088	93 			xchg	ax,bx
	*** 000089	2e ff a7 00 00 		jmp	WORD PTR cs:$L525[bx]
					$L525:
	*** 00008e	00 00 				DW	$SC451
	*** 000090	00 00 				DW	$SC451
	*** 000092	00 00 				DW	$SC452
	*** 000094	00 00 				DW	$SC453
	*** 000096	00 00 				DW	$SC451
	*** 000098	00 00 				DW	$SC451
;|***         default:    
; Line 176
					$SD454:
;|***         
;|***             // VESA mode value was passed in - use directly 
;|*** 
;|***             vesaMode = desiredMode;   /* use passed in mode value */
;|***             vesaMode |= 0x4000;       /* ask for linear/flat framebuffer mode */
; Line 181
	*** 00009a	8b 56 04 		mov	dx,WORD PTR [bp+4]	;desiredMode
	*** 00009d	80 ce 40 		or	dh,64	;0040H
;|***             scanLength = 0;           /* use mode default scan length */
; Line 182
	*** 0000a0	33 c9 			xor	cx,cx
;|***             break;
; Line 183
	*** 0000a2	eb 16 			jmp	SHORT $SB448
;|***         case 0x01:   // 480x240x256 is emulated in a partial 640x480x256 screen 
; Line 155
					$SC451:
;|***         case 0x02:
;|***         case 0x05:   // 240x320x256 is emulated in a partial 640x480x256 screen 
;|***         case 0x06:   // 208x240x256 is emulated in a partial 640x480x256 screen 
;|*** 
;|***             scanLength = VESASCANLENGTH1024;    // scan length for this mode 
; Line 160
	*** 0000a4	b9 00 04 		mov	cx,1024	;0400H
;|***             vesaMode = VESAMODE640x480x256;     // VESA Mode 101 640x480x256 
; Line 161
	*** 0000a7	ba 01 01 		mov	dx,257	;0101H
;|***             break;
; Line 162
	*** 0000aa	eb 0e 			jmp	SHORT $SB448
;|*** 
;|***         case 0x03:
; Line 164
					$SC452:
;|*** 
;|***             scanLength = VESASCANLENGTH1024;    // scan length for this mode 
; Line 166
	*** 0000ac	b9 00 04 		mov	cx,1024	;0400H
;|***             vesaMode = VESAMODE800x600x256;     // VESA Mode 103 800x600x256
; Line 167
	*** 0000af	ba 03 01 		mov	dx,259	;0103H
;|***             break;
; Line 168
	*** 0000b2	eb 06 			jmp	SHORT $SB448
;|*** 
;|***         case 0x04:
; Line 170
					$SC453:
;|*** 
;|***             scanLength = VESASCANLENGTH1024;    // scan length for this mode 
; Line 172
	*** 0000b4	b9 00 04 		mov	cx,1024	;0400H
;|***             vesaMode = VESAMODE1024x768x256;    // VESA Mode 105 1024x768x256 
; Line 173
	*** 0000b7	ba 05 01 		mov	dx,261	;0105H
;|***             break;
;|*** 
;|***         default:    
;|***         
;|***             // VESA mode value was passed in - use directly 
;|*** 
;|***             vesaMode = desiredMode;   /* use passed in mode value */
;|***             vesaMode |= 0x4000;       /* ask for linear/flat framebuffer mode */
;|***             scanLength = 0;           /* use mode default scan length */
;|***             break;
;|***         }
; Line 184
					$SB448:
;|*** 
;|***         // Setup the video card
;|*** 
;|***         if( setVesaMode( vesaMode, scanLength ) )
; Line 188
	*** 0000ba	51 			push	cx
	*** 0000bb	52 			push	dx
	*** 0000bc	e8 79 ff 		call	_setVesaMode
	*** 0000bf	8b e5 			mov	sp,bp
	*** 0000c1	0b c0 			or	ax,ax
	*** 0000c3	74 0d 			je	$I446
;|***         {
;|***             // Indicate status
;|*** 
;|***             return( (UCHAR)(desiredMode < 0x100 ? desiredMode : 0xFF) );   
; Line 192
	*** 0000c5	81 7e 04 00 01 		cmp	WORD PTR [bp+4],256	;0100H	;desiredMode
	*** 0000ca	7d a0 			jge	$L530
	*** 0000cc	8a 46 04 		mov	al,BYTE PTR [bp+4]	;desiredMode
	*** 0000cf	c9 			leave	
	*** 0000d0	c3 			ret	
	*** 0000d1	90 			nop	
;|***         }
;|***     }
;|*** 
;|***     // Set default mode if we get here
;|*** 
;|***     mode320x200x256();
; Line 198
					$I446:
	*** 0000d2	e8 2b ff 		call	_mode320x200x256
;|***     return( 0 );
; Line 199
	*** 0000d5	32 c0 			xor	al,al
;|*** }
; Line 200
	*** 0000d7	c9 			leave	
	*** 0000d8	c3 			ret	
	*** 0000d9	90 			nop	

_SetVideoMode	ENDP
	PUBLIC	_FindClosestVESAMode
_FindClosestVESAMode	PROC NEAR
;|*** 
;|*** //
;|*** // FindClosestVESAMode - Finds VESA mode with X and Y size closest to 
;|*** //  requested screen size.
;|*** //
;|*** // Returns flat framebuffer pointer, flat framebuffer stride, and physical X 
;|*** //  and Y size
;|*** //
;|*** 
;|*** void FindClosestVESAMode( void )
;|*** {
; Line 211
	*** 0000da	c8 1c 03 00 		enter	796,0
	*** 0000de	57 			push	di
	*** 0000df	56 			push	si
;	vesaInfo = -512
;	pVesaInfo = -516
;	modeInfo = -772
;	pModeInfo = -776
;	deltaX = -780
;	deltaY = -784
;	currError = -788
;	error = -792
;	vesaMode = -794
;	index = -796
;|***     VESA_GENERAL_INFO   vesaInfo, far *pVesaInfo = &vesaInfo;
; Line 212
	*** 0000e0	8d 86 00 fe 		lea	ax,WORD PTR [bp-512]	;vesaInfo
	*** 0000e4	89 86 fc fd 		mov	WORD PTR [bp-516],ax	;pVesaInfo
	*** 0000e8	8c 96 fe fd 		mov	WORD PTR [bp-514],ss
;|***     VESA_MODE_INFO      modeInfo, far *pModeInfo = &modeInfo;
; Line 213
	*** 0000ec	8d 8e fc fc 		lea	cx,WORD PTR [bp-772]	;modeInfo
	*** 0000f0	89 8e f8 fc 		mov	WORD PTR [bp-776],cx	;pModeInfo
	*** 0000f4	8c 96 fa fc 		mov	WORD PTR [bp-774],ss
;|***     DWORD               deltaX, deltaY;
;|***     DWORD               currError, error;
;|***     WORD                vesaMode;
;|***     int                 index;
;|*** 
;|***     //printf( "FindClosestVESAMode\n\r" );
;|*** 
;|***     vesaInfo.szSignature[0] = 'V';
; Line 221
	*** 0000f8	c6 86 00 fe 56 		mov	BYTE PTR [bp-512],86	;0056H	;vesaInfo
;|***     vesaInfo.szSignature[1] = 'B';
; Line 222
	*** 0000fd	c6 86 01 fe 42 		mov	BYTE PTR [bp-511],66	;0042H
;|***     vesaInfo.szSignature[2] = 'E';
; Line 223
	*** 000102	c6 86 02 fe 45 		mov	BYTE PTR [bp-510],69	;0045H
;|***     vesaInfo.szSignature[3] = '2';
; Line 224
	*** 000107	c6 86 03 fe 32 		mov	BYTE PTR [bp-509],50	;0032H
;|*** 
;|***     __asm
;|***     {
;|***         push    es
; Line 228
	*** 00010c	06 			push	es
;|***         mov     ax, 04F00h      ; Get VESA info
; Line 229
	*** 00010d	b8 00 4f 		mov	ax,20224	;4f00H
;|***         les     di, pVesaInfo   ; Pointer to info buffer
; Line 230
	*** 000110	c4 be fc fd 		les	di,DWORD PTR [bp-516]	;pVesaInfo
;|***         int     10h             ; check for VESA
; Line 231
	*** 000114	cd 10 			int	16	;0010H
;|***         pop     es
; Line 232
	*** 000116	07 			pop	es
;|*** 
;|***         cmp     ax, 0004Fh      ; Was it successful?
; Line 234
	*** 000117	3d 4f 00 		cmp	ax,79	;004fH
;|***         je      itsok
; Line 235
	*** 00011a	74 04 			je	$itsok468
;|***         jmp     noVesa
; Line 236
	*** 00011c	e9 73 01 		jmp	$noVesa469
;|***     }
; Line 237
	*** 00011f	90 			nop	
;|*** 
;|*** itsok:
; Line 239
					$itsok468:
;|*** 
;|***     // check for minimum compat version of VBE
;|*** 
;|***     if (vesaInfo.wVersion < 0x0200)    
; Line 243
	*** 000120	81 be 04 fe 00 02 	cmp	WORD PTR [bp-508],512	;0200H
	*** 000126	73 03 			jae	$JCC294
	*** 000128	e9 67 01 		jmp	$noVesa469
					$JCC294:
;|***     {
;|***         goto noVesa;
;|***     }
;|*** 
;|***     // Clear mode, set error to large value
;|*** 
;|***     BootArgs.vesaMode = 0;
; Line 250
	*** 00012b	c7 06 6c 00 00 00 	mov	WORD PTR _BootArgs+108,0
;|***     currError = 0xFFFFFFFF;
; Line 251
	*** 000131	c7 86 ec fc ff ff 	mov	WORD PTR [bp-788],-1	;ffffH	;currError
	*** 000137	c7 86 ee fc ff ff 	mov	WORD PTR [bp-786],-1	;ffffH
;|*** 
;|***     // Process the VESA mode list
;|*** 
;|***     for( index=0; vesaInfo.pModeList[index] != -1; index++ )
; Line 255
	*** 00013d	c7 86 e4 fc 00 00 	mov	WORD PTR [bp-796],0	;index
	*** 000143	e9 32 01 		jmp	$F471
					$FC472:
;|***     {
;|***         // Set mode we are checking
;|*** 
;|***         vesaMode = vesaInfo.pModeList[index];
; Line 259
	*** 000146	26 8b 00 		mov	ax,WORD PTR es:[bx][si]
	*** 000149	89 86 e6 fc 		mov	WORD PTR [bp-794],ax	;vesaMode
;|*** 
;|***         // Fetch the Mode Info
;|*** 
;|***         __asm
;|***         {
;|***             push    es
; Line 265
	*** 00014d	06 			push	es
;|***             mov     cx, vesaMode
; Line 266
	*** 00014e	8b 8e e6 fc 		mov	cx,WORD PTR [bp-794]	;vesaMode
;|***             les     di, pModeInfo   ; Pointer to info buffer
; Line 267
	*** 000152	c4 be f8 fc 		les	di,DWORD PTR [bp-776]	;pModeInfo
;|***             mov     ax, 04F01h      ; Return VBE Mode Information
; Line 268
	*** 000156	b8 01 4f 		mov	ax,20225	;4f01H
;|***             int     10h
; Line 269
	*** 000159	cd 10 			int	16	;0010H
;|***             pop     es
; Line 270
	*** 00015b	07 			pop	es
;|***         }
; Line 271
;|*** 
;|***         // Check Mode Info - the following are required:
;|***         //
;|***         // - planer mode
;|***         // - flat frame buffer compat mode
;|***         // - matching color depth
;|***         // - same size or bigger than requested
;|*** 
;|***         if( (modeInfo.ucNumberOfPlanes == 1)                        &&
;|***             (modeInfo.dwPhysBasePtr    != 0)                        &&  
;|***             (modeInfo.ucBitsPerPixel   == BootArgs.bppScreen)       && 
;|***             (modeInfo.wXResolution     >= BootArgs.cxDisplayScreen) &&
;|***             (modeInfo.wYResolution     >= BootArgs.cyDisplayScreen)  )
; Line 284
	*** 00015c	80 be 14 fd 01 		cmp	BYTE PTR [bp-748],1
	*** 000161	74 03 			je	$JCC353
	*** 000163	e9 0e 01 		jmp	$I477
					$JCC353:
	*** 000166	8b 86 26 fd 		mov	ax,WORD PTR [bp-730]
	*** 00016a	0b 86 24 fd 		or	ax,WORD PTR [bp-732]
	*** 00016e	75 03 			jne	$JCC366
	*** 000170	e9 01 01 		jmp	$I477
					$JCC366:
	*** 000173	8a 86 15 fd 		mov	al,BYTE PTR [bp-747]
	*** 000177	2a e4 			sub	ah,ah
	*** 000179	3b 06 78 00 		cmp	ax,WORD PTR _BootArgs+120
	*** 00017d	74 03 			je	$JCC381
	*** 00017f	e9 f2 00 		jmp	$I477
					$JCC381:
	*** 000182	a1 6e 00 		mov	ax,WORD PTR _BootArgs+110
	*** 000185	39 86 0e fd 		cmp	WORD PTR [bp-754],ax
	*** 000189	73 03 			jae	$JCC393
	*** 00018b	e9 e6 00 		jmp	$I477
					$JCC393:
	*** 00018e	a1 70 00 		mov	ax,WORD PTR _BootArgs+112
	*** 000191	39 86 10 fd 		cmp	WORD PTR [bp-752],ax
	*** 000195	73 03 			jae	$JCC405
	*** 000197	e9 da 00 		jmp	$I477
					$JCC405:
;|***         {
;|***             // only allow 565 16bpp modes through
;|*** 
;|***             if( (modeInfo.ucBitsPerPixel == 16) &&              
;|***                 ((modeInfo.ucRedMaskSize   != 5) || 
;|***                  (modeInfo.ucGreenMaskSize != 6) ||
;|***                  (modeInfo.ucBlueMaskSize  != 5)) )
; Line 291
	*** 00019a	80 be 15 fd 10 		cmp	BYTE PTR [bp-747],16	;0010H
	*** 00019f	75 1e 			jne	$I475
	*** 0001a1	80 be 1b fd 05 		cmp	BYTE PTR [bp-741],5
	*** 0001a6	74 03 			je	$JCC422
	*** 0001a8	e9 c9 00 		jmp	$I477
					$JCC422:
	*** 0001ab	80 be 1d fd 06 		cmp	BYTE PTR [bp-739],6
	*** 0001b0	74 03 			je	$JCC432
	*** 0001b2	e9 bf 00 		jmp	$I477
					$JCC432:
	*** 0001b5	80 be 1f fd 05 		cmp	BYTE PTR [bp-737],5
	*** 0001ba	74 03 			je	$JCC442
	*** 0001bc	e9 b5 00 		jmp	$I477
					$JCC442:
;|***             {
;|***                 continue;
;|***             }
;|*** 
;|***             // Compute screen resolution error
;|*** 
;|***             deltaX = (DWORD)modeInfo.wXResolution - 
; Line 298
					$I475:
;|***                      (DWORD)BootArgs.cxDisplayScreen;
; Line 299
	*** 0001bf	8b 86 0e fd 		mov	ax,WORD PTR [bp-754]
	*** 0001c3	2b d2 			sub	dx,dx
	*** 0001c5	2b 06 6e 00 		sub	ax,WORD PTR _BootArgs+110
	*** 0001c9	1b d2 			sbb	dx,dx
	*** 0001cb	89 86 f4 fc 		mov	WORD PTR [bp-780],ax	;deltaX
	*** 0001cf	89 96 f6 fc 		mov	WORD PTR [bp-778],dx
;|***             deltaY = (DWORD)modeInfo.wYResolution - 
;|***                      (DWORD)BootArgs.cyDisplayScreen;
; Line 301
	*** 0001d3	8b 8e 10 fd 		mov	cx,WORD PTR [bp-752]
	*** 0001d7	2b db 			sub	bx,bx
	*** 0001d9	2b 0e 70 00 		sub	cx,WORD PTR _BootArgs+112
	*** 0001dd	1b db 			sbb	bx,bx
	*** 0001df	89 8e f0 fc 		mov	WORD PTR [bp-784],cx	;deltaY
	*** 0001e3	89 9e f2 fc 		mov	WORD PTR [bp-782],bx
;|*** 
;|***             error = ((deltaX * deltaX) + (deltaY * deltaY));
; Line 303
	*** 0001e7	53 			push	bx
	*** 0001e8	51 			push	cx
	*** 0001e9	53 			push	bx
	*** 0001ea	51 			push	cx
	*** 0001eb	8b f0 			mov	si,ax
	*** 0001ed	8b fa 			mov	di,dx
	*** 0001ef	e8 00 00 		call	__aNulmul
	*** 0001f2	57 			push	di
	*** 0001f3	56 			push	si
	*** 0001f4	57 			push	di
	*** 0001f5	56 			push	si
	*** 0001f6	8b f0 			mov	si,ax
	*** 0001f8	8b fa 			mov	di,dx
	*** 0001fa	e8 00 00 		call	__aNulmul
	*** 0001fd	03 f0 			add	si,ax
	*** 0001ff	13 fa 			adc	di,dx
	*** 000201	89 b6 e8 fc 		mov	WORD PTR [bp-792],si	;error
	*** 000205	89 be ea fc 		mov	WORD PTR [bp-790],di
;|*** 
;|***             // If the error is diminishing save the mode data
;|*** 
;|***             if( error < currError )
; Line 307
	*** 000209	3b be ee fc 		cmp	di,WORD PTR [bp-786]
	*** 00020d	77 65 			ja	$I477
	*** 00020f	72 06 			jb	$L527
	*** 000211	3b b6 ec fc 		cmp	si,WORD PTR [bp-788]	;currError
	*** 000215	73 5d 			jae	$I477
					$L527:
;|***             {
;|***                 // Save the current error for next comparison
;|*** 
;|***                 currError = error;
; Line 311
	*** 000217	89 b6 ec fc 		mov	WORD PTR [bp-788],si	;currError
	*** 00021b	89 be ee fc 		mov	WORD PTR [bp-786],di
;|*** 
;|***                 // Update the boot args with current data
;|*** 
;|***                 BootArgs.vesaMode          = vesaMode;
; Line 315
	*** 00021f	8b 86 e6 fc 		mov	ax,WORD PTR [bp-794]	;vesaMode
	*** 000223	a3 6c 00 		mov	WORD PTR _BootArgs+108,ax
;|***                 BootArgs.pvFlatFrameBuffer = modeInfo.dwPhysBasePtr;
; Line 316
	*** 000226	8b 86 24 fd 		mov	ax,WORD PTR [bp-732]
	*** 00022a	8b 96 26 fd 		mov	dx,WORD PTR [bp-730]
	*** 00022e	a3 68 00 		mov	WORD PTR _BootArgs+104,ax
	*** 000231	89 16 6a 00 		mov	WORD PTR _BootArgs+106,dx
;|***                 BootArgs.cxPhysicalScreen  = modeInfo.wXResolution;
; Line 317
	*** 000235	8b 86 0e fd 		mov	ax,WORD PTR [bp-754]
	*** 000239	a3 72 00 		mov	WORD PTR _BootArgs+114,ax
;|***                 BootArgs.cyPhysicalScreen  = modeInfo.wYResolution;
; Line 318
	*** 00023c	8b 86 10 fd 		mov	ax,WORD PTR [bp-752]
	*** 000240	a3 74 00 		mov	WORD PTR _BootArgs+116,ax
;|***                 BootArgs.cbScanLineLength  = modeInfo.wBytesPerScanLine;
; Line 319
	*** 000243	8b 86 0c fd 		mov	ax,WORD PTR [bp-756]
	*** 000247	a3 76 00 		mov	WORD PTR _BootArgs+118,ax
;|***                 BootArgs.RedMaskSize       = modeInfo.ucRedMaskSize;
; Line 320
	*** 00024a	8a 86 1b fd 		mov	al,BYTE PTR [bp-741]
	*** 00024e	a2 7a 00 		mov	BYTE PTR _BootArgs+122,al
;|***                 BootArgs.RedMaskPosition   = modeInfo.ucRedFieldPosition;
; Line 321
	*** 000251	8a 86 1c fd 		mov	al,BYTE PTR [bp-740]
	*** 000255	a2 7b 00 		mov	BYTE PTR _BootArgs+123,al
;|***                 BootArgs.GreenMaskSize     = modeInfo.ucGreenMaskSize;
; Line 322
	*** 000258	8a 86 1d fd 		mov	al,BYTE PTR [bp-739]
	*** 00025c	a2 7c 00 		mov	BYTE PTR _BootArgs+124,al
;|***                 BootArgs.GreenMaskPosition = modeInfo.ucGreenFieldPosition;
; Line 323
	*** 00025f	8a 86 1e fd 		mov	al,BYTE PTR [bp-738]
	*** 000263	a2 7d 00 		mov	BYTE PTR _BootArgs+125,al
;|***                 BootArgs.BlueMaskSize      = modeInfo.ucBlueMaskSize;
; Line 324
	*** 000266	8a 86 1f fd 		mov	al,BYTE PTR [bp-737]
	*** 00026a	a2 7e 00 		mov	BYTE PTR _BootArgs+126,al
;|***                 BootArgs.BlueMaskPosition  = modeInfo.ucBlueFieldPosition;
; Line 325
	*** 00026d	8a 86 20 fd 		mov	al,BYTE PTR [bp-736]
	*** 000271	a2 7f 00 		mov	BYTE PTR _BootArgs+127,al
;|***             }
;|***         }
; Line 327
					$I477:
;|***     }
; Line 328
	*** 000274	ff 86 e4 fc 		inc	WORD PTR [bp-796]	;index
					$F471:
	*** 000278	8b 9e e4 fc 		mov	bx,WORD PTR [bp-796]	;index
	*** 00027c	03 db 			add	bx,bx
	*** 00027e	c4 b6 0e fe 		les	si,DWORD PTR [bp-498]
	*** 000282	26 83 38 ff 		cmp	WORD PTR es:[bx][si],-1	;ffffH
	*** 000286	74 03 			je	$JCC646
	*** 000288	e9 bb fe 		jmp	$FC472
					$JCC646:
;|*** 
;|*** 
;|***     if( BootArgs.vesaMode == 0)
; Line 331
	*** 00028b	83 3e 6c 00 00 		cmp	WORD PTR _BootArgs+108,0
	*** 000290	75 06 			jne	$EX457
;|***     {
;|***         goto noVesa;
; Line 333
					$noVesa469:
;|***     }
;|*** 
;|***     return;
;|*** 
;|*** noVesa: 
;|*** 
;|***     // no matching VESA mode found, use 320x200x8 video mode as fallback
;|*** 
;|***     BootArgs.vesaMode = 0;
; Line 342
	*** 000292	c7 06 6c 00 00 00 	mov	WORD PTR _BootArgs+108,0
;|*** }
; Line 343
					$EX457:
	*** 000298	5e 			pop	si
	*** 000299	5f 			pop	di
	*** 00029a	c9 			leave	
	*** 00029b	c3 			ret	

_FindClosestVESAMode	ENDP
	PUBLIC	_FindVESAMode
_FindVESAMode	PROC NEAR
;|*** 
;|*** //
;|*** // FindVESAMode - Finds VESA mode which exactly matches requested X and Y size
;|*** // Returns flat framebuffer pointer and flat framebuffer stride
;|*** //
;|*** 
;|*** void FindVESAMode( void )
;|*** {
; Line 351
	*** 00029c	c8 0c 03 00 		enter	780,0
	*** 0002a0	57 			push	di
	*** 0002a1	56 			push	si
;	vesaInfo = -512
;	pVesaInfo = -516
;	modeInfo = -772
;	pModeInfo = -776
;	vesaMode = -778
;	index = -780
;|***     VESA_GENERAL_INFO   vesaInfo, far *pVesaInfo = &vesaInfo;
; Line 352
	*** 0002a2	8d 86 00 fe 		lea	ax,WORD PTR [bp-512]	;vesaInfo
	*** 0002a6	89 86 fc fd 		mov	WORD PTR [bp-516],ax	;pVesaInfo
	*** 0002aa	8c 96 fe fd 		mov	WORD PTR [bp-514],ss
;|***     VESA_MODE_INFO      modeInfo, far *pModeInfo = &modeInfo;
; Line 353
	*** 0002ae	8d 8e fc fc 		lea	cx,WORD PTR [bp-772]	;modeInfo
	*** 0002b2	89 8e f8 fc 		mov	WORD PTR [bp-776],cx	;pModeInfo
	*** 0002b6	8c 96 fa fc 		mov	WORD PTR [bp-774],ss
;|***     WORD                vesaMode;
;|***     int                 index;
;|*** 
;|*** 	//printf( "FindVesaMode( void )\n" );
;|*** 
;|***     vesaInfo.szSignature[0] = 'V';
; Line 359
	*** 0002ba	c6 86 00 fe 56 		mov	BYTE PTR [bp-512],86	;0056H	;vesaInfo
;|***     vesaInfo.szSignature[1] = 'B';
; Line 360
	*** 0002bf	c6 86 01 fe 42 		mov	BYTE PTR [bp-511],66	;0042H
;|***     vesaInfo.szSignature[2] = 'E';
; Line 361
	*** 0002c4	c6 86 02 fe 45 		mov	BYTE PTR [bp-510],69	;0045H
;|***     vesaInfo.szSignature[3] = '2';
; Line 362
	*** 0002c9	c6 86 03 fe 32 		mov	BYTE PTR [bp-509],50	;0032H
;|*** 
;|***     // Fetch the VESA info data
;|*** 
;|***     __asm
;|***     {
;|***         push    es
; Line 368
	*** 0002ce	06 			push	es
;|***         mov     ax, 04F00h      ; Get VESA info
; Line 369
	*** 0002cf	b8 00 4f 		mov	ax,20224	;4f00H
;|***         les     di, pVesaInfo   ; Pointer to info buffer
; Line 370
	*** 0002d2	c4 be fc fd 		les	di,DWORD PTR [bp-516]	;pVesaInfo
;|***         int     10h             ; check for VESA
; Line 371
	*** 0002d6	cd 10 			int	16	;0010H
;|***         pop     es
; Line 372
	*** 0002d8	07 			pop	es
;|*** 
;|***         cmp     ax, 0004Fh      ; Was it successful?
; Line 374
	*** 0002d9	3d 4f 00 		cmp	ax,79	;004fH
;|***         je      itsok
; Line 375
	*** 0002dc	74 04 			je	$itsok487
;|***         jmp     noVesa
; Line 376
	*** 0002de	e9 c2 00 		jmp	$noVesa488
;|***     }
; Line 377
	*** 0002e1	90 			nop	
;|*** 
;|*** itsok:
; Line 379
					$itsok487:
;|*** 
;|***     // Validate minimum compatibility version of VBE
;|*** 
;|***     if( vesaInfo.wVersion < 0x0200 )     
; Line 383
	*** 0002e2	81 be 04 fe 00 02 	cmp	WORD PTR [bp-508],512	;0200H
	*** 0002e8	73 03 			jae	$JCC744
	*** 0002ea	e9 b6 00 		jmp	$noVesa488
					$JCC744:
;|***     {
;|***         goto noVesa;
;|***     }
;|*** 
;|***     // Clear mode
;|*** 
;|***     BootArgs.vesaMode = 0;
; Line 390
	*** 0002ed	c7 06 6c 00 00 00 	mov	WORD PTR _BootArgs+108,0
;|*** 
;|***     // Process the VESA ModeList
;|*** 
;|***     for( index=0; vesaInfo.pModeList[index] != -1; index++ )
; Line 394
	*** 0002f3	c7 86 f4 fc 00 00 	mov	WORD PTR [bp-780],0	;index
	*** 0002f9	e9 94 00 		jmp	$F490
					$FC491:
;|***     {
;|***         // Set mode we are checking
;|*** 
;|***         vesaMode = vesaInfo.pModeList[index];
; Line 398
	*** 0002fc	26 8b 00 		mov	ax,WORD PTR es:[bx][si]
	*** 0002ff	89 86 f6 fc 		mov	WORD PTR [bp-778],ax	;vesaMode
;|*** 
;|***         // Fetch the Mode Info
;|*** 
;|***         __asm
;|***         {
;|***             push    es
; Line 404
	*** 000303	06 			push	es
;|***             mov     cx, vesaMode
; Line 405
	*** 000304	8b 8e f6 fc 		mov	cx,WORD PTR [bp-778]	;vesaMode
;|***             les     di, pModeInfo   ; Pointer to info buffer
; Line 406
	*** 000308	c4 be f8 fc 		les	di,DWORD PTR [bp-776]	;pModeInfo
;|***             mov     ax, 04F01h      ; Return VBE Mode Information
; Line 407
	*** 00030c	b8 01 4f 		mov	ax,20225	;4f01H
;|***             int     10h
; Line 408
	*** 00030f	cd 10 			int	16	;0010H
;|***             pop     es
; Line 409
	*** 000311	07 			pop	es
;|***         }
; Line 410
;|*** 
;|***         // Check Mode Info - the following are required:
;|***         //
;|***         // - planer mode
;|***         // - flat frame buffer compat mode
;|***         // - matching color depth
;|***         // - same size or bigger than requested
;|*** 
;|***         if( (modeInfo.ucNumberOfPlanes == 1)                         &&     
;|***             (modeInfo.dwPhysBasePtr    != 0)                         &&     
;|***             (modeInfo.ucBitsPerPixel   == BootArgs.bppScreen)        &&    
;|***             (modeInfo.wXResolution     == BootArgs.cxPhysicalScreen) &&  
;|***             (modeInfo.wYResolution     == BootArgs.cyPhysicalScreen)  )
; Line 423
	*** 000312	80 be 14 fd 01 		cmp	BYTE PTR [bp-748],1
	*** 000317	75 73 			jne	$L532
	*** 000319	8b 86 26 fd 		mov	ax,WORD PTR [bp-730]
	*** 00031d	0b 86 24 fd 		or	ax,WORD PTR [bp-732]
	*** 000321	74 69 			je	$L532
	*** 000323	8a 86 15 fd 		mov	al,BYTE PTR [bp-747]
	*** 000327	2a e4 			sub	ah,ah
	*** 000329	3b 06 78 00 		cmp	ax,WORD PTR _BootArgs+120
	*** 00032d	75 5d 			jne	$L532
	*** 00032f	a1 72 00 		mov	ax,WORD PTR _BootArgs+114
	*** 000332	39 86 0e fd 		cmp	WORD PTR [bp-754],ax
	*** 000336	75 54 			jne	$L532
	*** 000338	a1 74 00 		mov	ax,WORD PTR _BootArgs+116
	*** 00033b	39 86 10 fd 		cmp	WORD PTR [bp-752],ax
	*** 00033f	75 4b 			jne	$L532
;|***         {
;|***             // Conditions are met. Set BootArgs with Mode data and return.
;|*** 
;|***             BootArgs.vesaMode          = vesaMode;
; Line 427
	*** 000341	8b 86 f6 fc 		mov	ax,WORD PTR [bp-778]	;vesaMode
	*** 000345	a3 6c 00 		mov	WORD PTR _BootArgs+108,ax
;|***             BootArgs.pvFlatFrameBuffer = modeInfo.dwPhysBasePtr;
; Line 428
	*** 000348	8b 86 24 fd 		mov	ax,WORD PTR [bp-732]
	*** 00034c	8b 96 26 fd 		mov	dx,WORD PTR [bp-730]
	*** 000350	a3 68 00 		mov	WORD PTR _BootArgs+104,ax
	*** 000353	89 16 6a 00 		mov	WORD PTR _BootArgs+106,dx
;|***             BootArgs.cbScanLineLength  = modeInfo.wBytesPerScanLine;
; Line 429
	*** 000357	8b 86 0c fd 		mov	ax,WORD PTR [bp-756]
	*** 00035b	a3 76 00 		mov	WORD PTR _BootArgs+118,ax
;|***             BootArgs.RedMaskSize       = modeInfo.ucRedMaskSize;
; Line 430
	*** 00035e	8a 86 1b fd 		mov	al,BYTE PTR [bp-741]
	*** 000362	a2 7a 00 		mov	BYTE PTR _BootArgs+122,al
;|***             BootArgs.RedMaskPosition   = modeInfo.ucRedFieldPosition;
; Line 431
	*** 000365	8a 86 1c fd 		mov	al,BYTE PTR [bp-740]
	*** 000369	a2 7b 00 		mov	BYTE PTR _BootArgs+123,al
;|***             BootArgs.GreenMaskSize     = modeInfo.ucGreenMaskSize;
; Line 432
	*** 00036c	8a 86 1d fd 		mov	al,BYTE PTR [bp-739]
	*** 000370	a2 7c 00 		mov	BYTE PTR _BootArgs+124,al
;|***             BootArgs.GreenMaskPosition = modeInfo.ucGreenFieldPosition;
; Line 433
	*** 000373	8a 86 1e fd 		mov	al,BYTE PTR [bp-738]
	*** 000377	a2 7d 00 		mov	BYTE PTR _BootArgs+125,al
;|***             BootArgs.BlueMaskSize      = modeInfo.ucBlueMaskSize;
; Line 434
	*** 00037a	8a 86 1f fd 		mov	al,BYTE PTR [bp-737]
	*** 00037e	a2 7e 00 		mov	BYTE PTR _BootArgs+126,al
;|***             BootArgs.BlueMaskPosition  = modeInfo.ucBlueFieldPosition;
; Line 435
	*** 000381	8a 86 20 fd 		mov	al,BYTE PTR [bp-736]
	*** 000385	a2 7f 00 		mov	BYTE PTR _BootArgs+127,al
;|***             return;
; Line 436
	*** 000388	5e 			pop	si
	*** 000389	5f 			pop	di
	*** 00038a	c9 			leave	
	*** 00038b	c3 			ret	
;|***         }
;|***     }
; Line 438
					$L532:
	*** 00038c	ff 86 f4 fc 		inc	WORD PTR [bp-780]	;index
					$F490:
	*** 000390	8b 9e f4 fc 		mov	bx,WORD PTR [bp-780]	;index
	*** 000394	03 db 			add	bx,bx
	*** 000396	c4 b6 0e fe 		les	si,DWORD PTR [bp-498]
	*** 00039a	26 83 38 ff 		cmp	WORD PTR es:[bx][si],-1	;ffffH
	*** 00039e	74 03 			je	$JCC926
	*** 0003a0	e9 59 ff 		jmp	$FC491
					$JCC926:
;|*** 
;|*** noVesa: 
; Line 440
					$noVesa488:
;|*** 
;|***     // No matching VESA mode found, use 320x200x8 as fallback
;|*** 
;|***     BootArgs.vesaMode = 0;
; Line 444
	*** 0003a3	c7 06 6c 00 00 00 	mov	WORD PTR _BootArgs+108,0
;|*** }
; Line 445
	*** 0003a9	5e 			pop	si
	*** 0003aa	5f 			pop	di
	*** 0003ab	c9 			leave	
	*** 0003ac	c3 			ret	
	*** 0003ad	90 			nop	

_FindVESAMode	ENDP
	PUBLIC	_ParseVESAOptions
_ParseVESAOptions	PROC NEAR
;|*** 
;|*** //
;|*** //  ParseVESAOptions
;|*** //
;|*** 
;|*** BOOL ParseVESAOptions( char *params )
;|*** {
; Line 452
	*** 0003ae	55 			push	bp
	*** 0003af	8b ec 			mov	bp,sp
	*** 0003b1	57 			push	di
	*** 0003b2	56 			push	si
;	params = 4
;	register si = cArgs
	*** 0003b3	8b 56 04 		mov	dx,WORD PTR [bp+4]	;params
;|***     int cArgs;
;|*** 
;|*** 	//printf( "ParseVESAOptions( 0x%x )\n", params );
;|*** 
;|***     // Clear mode   
;|*** 
;|***     BootArgs.vesaMode = 0;
; Line 459
	*** 0003b6	c7 06 6c 00 00 00 	mov	WORD PTR _BootArgs+108,0
;|*** 
;|***     // Verify option format is /L:
;|*** 
;|***     if (params[2] != ':')
; Line 463
	*** 0003bc	8b da 			mov	bx,dx
	*** 0003be	80 7f 02 3a 		cmp	BYTE PTR [bx+2],58	;003aH
	*** 0003c2	74 06 			je	$I499
;|***     {
;|***         return( FALSE );            // colon after /L missing, exit
; Line 465
					$L533:
	*** 0003c4	33 c0 			xor	ax,ax
	*** 0003c6	5e 			pop	si
	*** 0003c7	5f 			pop	di
	*** 0003c8	c9 			leave	
	*** 0003c9	c3 			ret	
;|***     }
;|*** 
;|***     // Check for the N format of the option, /L:N:xxx. This 
;|***     // mode skips all the VESA mode processing and the mode set.
;|*** 
;|***     if( (memcmp( &params[3],"N:",2) == 0) || (memcmp( &params[3],"n:",2) == 0) )
; Line 471
					$I499:
	*** 0003ca	8b c2 			mov	ax,dx
	*** 0003cc	05 03 00 		add	ax,3
	*** 0003cf	bb 00 00 		mov	bx,OFFSET DGROUP:$SG502
	*** 0003d2	b9 02 00 		mov	cx,2
	*** 0003d5	8b fb 			mov	di,bx
	*** 0003d7	8b f0 			mov	si,ax
	*** 0003d9	1e 			push	ds
	*** 0003da	07 			pop	es
	*** 0003db	d1 e9 			shr	cx,1
	*** 0003dd	1b c0 			sbb	ax,ax
	*** 0003df	3b c9 			cmp	cx,cx
	*** 0003e1	f3 			repz
	*** 0003e2	a7 			cmpsw
	*** 0003e3	75 04 			jne	$L528
	*** 0003e5	2b c8 			sub	cx,ax
	*** 0003e7	f3 			repz
	*** 0003e8	a6 			cmpsb
					$L528:
	*** 0003e9	74 77 			je	$I501
	*** 0003eb	8b c2 			mov	ax,dx
	*** 0003ed	05 03 00 		add	ax,3
	*** 0003f0	bb 00 00 		mov	bx,OFFSET DGROUP:$SG503
	*** 0003f3	b9 02 00 		mov	cx,2
	*** 0003f6	8b fb 			mov	di,bx
	*** 0003f8	8b f0 			mov	si,ax
	*** 0003fa	d1 e9 			shr	cx,1
	*** 0003fc	1b c0 			sbb	ax,ax
	*** 0003fe	3b c9 			cmp	cx,cx
	*** 000400	f3 			repz
	*** 000401	a7 			cmpsw
	*** 000402	75 04 			jne	$L529
	*** 000404	2b c8 			sub	cx,ax
	*** 000406	f3 			repz
	*** 000407	a6 			cmpsb
					$L529:
	*** 000408	74 58 			je	$I501
;|***     {
;|***         bNoModeSet = TRUE;
;|*** 
;|***         cArgs = sscanf( &params[5], "%dx%dx%d:%dx%d",
;|***                         &BootArgs.cxDisplayScreen,
;|***                         &BootArgs.cyDisplayScreen,
;|***                         &BootArgs.bppScreen,
;|***                         &BootArgs.cxPhysicalScreen,
;|***                         &BootArgs.cyPhysicalScreen );
;|***         if(cArgs == 3)
;|***         {
;|***             BootArgs.cxPhysicalScreen = BootArgs.cxDisplayScreen;
;|***             BootArgs.cyPhysicalScreen = BootArgs.cyDisplayScreen;
;|***         }
;|***         else if(cArgs == 5)
;|***         {
;|***             if (BootArgs.cxPhysicalScreen < BootArgs.cxDisplayScreen ||
;|***                 BootArgs.cyPhysicalScreen < BootArgs.cyDisplayScreen)
;|***             {
;|***                 printf
;|***                 ( 
;|*** "ERROR: The physical screen dimensions (PX & PY) should be larger than the\n"
;|*** "       display resolution chosen. This option is used to simulate a \n"
;|*** "       smaller drawing area on a larger display.\n"
;|***                 );
;|*** 
;|***                 // The physical screen size must be >= display screen size
;|*** 
;|***                 return( FALSE );      
;|***             }
;|***         }
;|***         BootArgs.vesaMode = 0xffff;     // just some really large value
;|***     }
;|***     else    
;|***     {
;|***         // No 'N' present in option. Process and set the VESA mode
;|*** 
;|***         bNoModeSet = FALSE;
; Line 509
	*** 00040a	c7 06 00 00 00 00 	mov	WORD PTR $S422_bNoModeSet,0
;|*** 
;|***         cArgs = sscanf( &params[3], "%dx%dx%d:%dx%d",
;|***                         &BootArgs.cxDisplayScreen,
;|***                         &BootArgs.cyDisplayScreen,
;|***                         &BootArgs.bppScreen,
;|***                         &BootArgs.cxPhysicalScreen,
;|***                         &BootArgs.cyPhysicalScreen );
;|*** 
;|***         // Process according to # of args specified
;|*** 
;|***         switch( cArgs )
; Line 520
	*** 000410	68 74 00 		push	OFFSET _BootArgs+116
	*** 000413	68 72 00 		push	OFFSET _BootArgs+114
	*** 000416	68 78 00 		push	OFFSET _BootArgs+120
	*** 000419	68 70 00 		push	OFFSET _BootArgs+112
	*** 00041c	68 6e 00 		push	OFFSET _BootArgs+110
	*** 00041f	68 00 00 		push	OFFSET DGROUP:$SG512
	*** 000422	83 c2 03 		add	dx,3
	*** 000425	52 			push	dx
	*** 000426	e8 00 00 		call	_sscanf
	*** 000429	83 c4 0e 		add	sp,14	;000eH
;|***         {
;|***         case 3:
;|*** 
;|***             // Explicit physical size not specified - find closest one
;|*** 
;|***             FindClosestVESAMode();      // uses and fills in BootArgs values
;|***             break;
;|*** 
;|***         case 5:
;|*** 
;|***             // Validate specified physical size
;|*** 
;|***             if( BootArgs.cxPhysicalScreen < BootArgs.cxDisplayScreen ||
;|***                 BootArgs.cyPhysicalScreen < BootArgs.cyDisplayScreen )
;|***             {
;|***                 printf
;|***                 (
;|*** "ERROR: The physical screen dimensions (PX & PY) should be larger than the\n"
;|*** "       display resolution chosen.  This option is used to simulate a \n"
;|*** "       smaller drawing area on a larger display.\n"
;|***                 );
;|***                 
;|***                 // The physical screen size must be >= display screen size
;|*** 
;|***                 return( FALSE );      
;|***             }
;|*** 
;|***             // Find the actual VESA mode
;|*** 
;|***             FindVESAMode();             // uses and fills in BootArgs values
;|***             break;
;|*** 
;|***         default:
;|*** 
;|***             // Invalid number of parameters
;|*** 
;|***             return( FALSE );
;|***             break;
;|***         }   
; Line 559
	*** 00042c	2d 03 00 		sub	ax,3
	*** 00042f	74 07 			je	$SC517
	*** 000431	48 			dec	ax
	*** 000432	48 			dec	ax
	*** 000433	74 09 			je	$SC518
;|***         default:
; Line 553
	*** 000435	eb 8d 			jmp	SHORT $L533
	*** 000437	90 			nop	
;|***         case 3:
; Line 522
					$SC517:
;|*** 
;|***             // Explicit physical size not specified - find closest one
;|*** 
;|***             FindClosestVESAMode();      // uses and fills in BootArgs values
; Line 526
	*** 000438	e8 9f fc 		call	_FindClosestVESAMode
;|***             break;
; Line 527
	*** 00043b	eb 7f 			jmp	SHORT $I511
	*** 00043d	90 			nop	
;|*** 
;|***         case 5:
; Line 529
					$SC518:
;|*** 
;|***             // Validate specified physical size
;|*** 
;|***             if( BootArgs.cxPhysicalScreen < BootArgs.cxDisplayScreen ||
;|***                 BootArgs.cyPhysicalScreen < BootArgs.cyDisplayScreen )
; Line 534
	*** 00043e	a1 72 00 		mov	ax,WORD PTR _BootArgs+114
	*** 000441	39 06 6e 00 		cmp	WORD PTR _BootArgs+110,ax
	*** 000445	77 0f 			ja	$I520
	*** 000447	a1 74 00 		mov	ax,WORD PTR _BootArgs+116
	*** 00044a	39 06 70 00 		cmp	WORD PTR _BootArgs+112,ax
	*** 00044e	77 06 			ja	$I520
;|***             {
;|***                 printf
;|***                 (
;|*** "ERROR: The physical screen dimensions (PX & PY) should be larger than the\n"
;|*** "       display resolution chosen.  This option is used to simulate a \n"
;|*** "       smaller drawing area on a larger display.\n"
;|***                 );
;|***                 
;|***                 // The physical screen size must be >= display screen size
;|*** 
;|***                 return( FALSE );      
;|***             }
;|*** 
;|***             // Find the actual VESA mode
;|*** 
;|***             FindVESAMode();             // uses and fills in BootArgs values
; Line 550
	*** 000450	e8 49 fe 		call	_FindVESAMode
;|***             break;
; Line 551
	*** 000453	eb 67 			jmp	SHORT $I511
	*** 000455	90 			nop	
;|***                 BootArgs.cyPhysicalScreen < BootArgs.cyDisplayScreen )
; Line 534
					$I520:
;|***             {
;|***                 printf
;|***                 (
;|*** "ERROR: The physical screen dimensions (PX & PY) should be larger than the\n"
;|*** "       display resolution chosen.  This option is used to simulate a \n"
;|*** "       smaller drawing area on a larger display.\n"
;|***                 );
; Line 541
	*** 000456	68 00 00 		push	OFFSET DGROUP:$SG521
					$L534:
	*** 000459	e8 00 00 		call	_printf
	*** 00045c	83 c4 02 		add	sp,2
	*** 00045f	e9 62 ff 		jmp	$L533
;|***     if( (memcmp( &params[3],"N:",2) == 0) || (memcmp( &params[3],"n:",2) == 0) )
; Line 471
					$I501:
;|***     {
;|***         bNoModeSet = TRUE;
; Line 473
	*** 000462	c7 06 00 00 01 00 	mov	WORD PTR $S422_bNoModeSet,1
;|*** 
;|***         cArgs = sscanf( &params[5], "%dx%dx%d:%dx%d",
;|***                         &BootArgs.cxDisplayScreen,
;|***                         &BootArgs.cyDisplayScreen,
;|***                         &BootArgs.bppScreen,
;|***                         &BootArgs.cxPhysicalScreen,
;|***                         &BootArgs.cyPhysicalScreen );
;|***         if(cArgs == 3)
; Line 481
	*** 000468	68 74 00 		push	OFFSET _BootArgs+116
	*** 00046b	68 72 00 		push	OFFSET _BootArgs+114
	*** 00046e	68 78 00 		push	OFFSET _BootArgs+120
	*** 000471	68 70 00 		push	OFFSET _BootArgs+112
	*** 000474	68 6e 00 		push	OFFSET _BootArgs+110
	*** 000477	68 00 00 		push	OFFSET DGROUP:$SG504
	*** 00047a	83 c2 05 		add	dx,5
	*** 00047d	52 			push	dx
	*** 00047e	e8 00 00 		call	_sscanf
	*** 000481	83 c4 0e 		add	sp,14	;000eH
	*** 000484	8b f0 			mov	si,ax
	*** 000486	83 fe 03 		cmp	si,3
	*** 000489	75 0f 			jne	$I505
;|***         {
;|***             BootArgs.cxPhysicalScreen = BootArgs.cxDisplayScreen;
; Line 483
	*** 00048b	a1 6e 00 		mov	ax,WORD PTR _BootArgs+110
	*** 00048e	a3 72 00 		mov	WORD PTR _BootArgs+114,ax
;|***             BootArgs.cyPhysicalScreen = BootArgs.cyDisplayScreen;
; Line 484
	*** 000491	a1 70 00 		mov	ax,WORD PTR _BootArgs+112
	*** 000494	a3 74 00 		mov	WORD PTR _BootArgs+116,ax
;|***         }
;|***         else if(cArgs == 5)
; Line 486
	*** 000497	eb 1d 			jmp	SHORT $I506
	*** 000499	90 			nop	
					$I505:
	*** 00049a	83 fe 05 		cmp	si,5
	*** 00049d	75 17 			jne	$I506
;|***         {
;|***             if (BootArgs.cxPhysicalScreen < BootArgs.cxDisplayScreen ||
;|***                 BootArgs.cyPhysicalScreen < BootArgs.cyDisplayScreen)
; Line 489
	*** 00049f	a1 72 00 		mov	ax,WORD PTR _BootArgs+114
	*** 0004a2	39 06 6e 00 		cmp	WORD PTR _BootArgs+110,ax
	*** 0004a6	77 09 			ja	$I509
	*** 0004a8	a1 74 00 		mov	ax,WORD PTR _BootArgs+116
	*** 0004ab	39 06 70 00 		cmp	WORD PTR _BootArgs+112,ax
	*** 0004af	76 05 			jbe	$I506
					$I509:
;|***             {
;|***                 printf
;|***                 ( 
;|*** "ERROR: The physical screen dimensions (PX & PY) should be larger than the\n"
;|*** "       display resolution chosen. This option is used to simulate a \n"
;|*** "       smaller drawing area on a larger display.\n"
;|***                 );
; Line 496
	*** 0004b1	68 00 00 		push	OFFSET DGROUP:$SG510
	*** 0004b4	eb a3 			jmp	SHORT $L534
;|*** 
;|***                 // The physical screen size must be >= display screen size
;|*** 
;|***                 return( FALSE );      
;|***             }
;|***         }
;|***         BootArgs.vesaMode = 0xffff;     // just some really large value
; Line 503
					$I506:
	*** 0004b6	c7 06 6c 00 ff ff 	mov	WORD PTR _BootArgs+108,-1	;ffffH
;|***     }
;|***     else    
;|***     {
;|***         // No 'N' present in option. Process and set the VESA mode
;|*** 
;|***         bNoModeSet = FALSE;
;|*** 
;|***         cArgs = sscanf( &params[3], "%dx%dx%d:%dx%d",
;|***                         &BootArgs.cxDisplayScreen,
;|***                         &BootArgs.cyDisplayScreen,
;|***                         &BootArgs.bppScreen,
;|***                         &BootArgs.cxPhysicalScreen,
;|***                         &BootArgs.cyPhysicalScreen );
;|*** 
;|***         // Process according to # of args specified
;|*** 
;|***         switch( cArgs )
;|***         {
;|***         case 3:
;|*** 
;|***             // Explicit physical size not specified - find closest one
;|*** 
;|***             FindClosestVESAMode();      // uses and fills in BootArgs values
;|***             break;
;|*** 
;|***         case 5:
;|*** 
;|***             // Validate specified physical size
;|*** 
;|***             if( BootArgs.cxPhysicalScreen < BootArgs.cxDisplayScreen ||
;|***                 BootArgs.cyPhysicalScreen < BootArgs.cyDisplayScreen )
;|***             {
;|***                 printf
;|***                 (
;|*** "ERROR: The physical screen dimensions (PX & PY) should be larger than the\n"
;|*** "       display resolution chosen.  This option is used to simulate a \n"
;|*** "       smaller drawing area on a larger display.\n"
;|***                 );
;|***                 
;|***                 // The physical screen size must be >= display screen size
;|*** 
;|***                 return( FALSE );      
;|***             }
;|*** 
;|***             // Find the actual VESA mode
;|*** 
;|***             FindVESAMode();             // uses and fills in BootArgs values
;|***             break;
;|*** 
;|***         default:
;|*** 
;|***             // Invalid number of parameters
;|*** 
;|***             return( FALSE );
;|***             break;
;|***         }   
;|***     }
; Line 560
					$I511:
;|*** 
;|***     // Indicate success
;|*** 
;|***     return( TRUE );
; Line 564
	*** 0004bc	b8 01 00 		mov	ax,1
;|*** }
; Line 565
	*** 0004bf	5e 			pop	si
	*** 0004c0	5f 			pop	di
	*** 0004c1	c9 			leave	
	*** 0004c2	c3 			ret	
	*** 0004c3	90 			nop	

_ParseVESAOptions	ENDP
_TEXT	ENDS
END
