;	Static Name Aliases
;
;	$S775_?ucBuffer@?1??LoadImage@@9@9	EQU	?ucBuffer@?1??LoadImage@@9@9
;	$S519_BootHeader	EQU	BootHeader
;	$S520_BootTail	EQU	BootTail
;	$S777_?ucSignature@?1??LoadImage@@9@9	EQU	?ucSignature@?1??LoadImage@@9@9
	TITLE   main.c
	.286p
	.287
INCLUDELIB      SLIBCE
INCLUDELIB	OLDNAMES.LIB
_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT  BYTE PUBLIC 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT  BYTE PUBLIC 'DEBTYP'
$$TYPES	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP, SS: DGROUP
PUBLIC  _BaudTable
PUBLIC  _bSerialDownload
PUBLIC  _iDesiredMode
EXTRN	__acrtused:ABS
EXTRN	_fprintf:NEAR
EXTRN	_XmsErrorString:NEAR
EXTRN	_signal:NEAR
EXTRN	__filelength:NEAR
EXTRN	_fseek:NEAR
EXTRN	__open:NEAR
EXTRN	__read:NEAR
EXTRN	_OEMInitDebugSerial:NEAR
EXTRN	_atol:NEAR
EXTRN	_printf:NEAR
EXTRN	__strerror:NEAR
EXTRN	_OEMReadDebugBytes:NEAR
EXTRN	_exit:NEAR
EXTRN	_OEMWriteDebugByte:NEAR
EXTRN	_OEMParallelPortGetByte:NEAR
EXTRN	_XmsIsInstalled:NEAR
EXTRN	_XmsLocalEnableA20:NEAR
EXTRN	_OEMParallelPortSendByte:NEAR
EXTRN	_strrchr:NEAR
EXTRN	_OEMParallelPortInit:NEAR
EXTRN	_XmsQueryA20:NEAR
EXTRN	_Launch:NEAR
EXTRN	_XmsQueryFreeExtendedMemory:NEAR
EXTRN	_SetVideoMode:NEAR
EXTRN	_ParseVESAOptions:NEAR
EXTRN	_XmsAllocateExtendedMemory:NEAR
EXTRN	_ParseEthernetOptions:NEAR
EXTRN	_XmsFreeExtendedMemory:NEAR
EXTRN	_ParseDeviceName:NEAR
EXTRN	_DrawPercent:NEAR
EXTRN	_fclose:NEAR
EXTRN	_DisplayDirectory:NEAR
EXTRN	_XmsMoveExtendedMemory:NEAR
EXTRN	_fgetc:NEAR
EXTRN	_tolower:NEAR
EXTRN	_XmsLockExtendedMemory:NEAR
EXTRN	_GetFile:NEAR
EXTRN	_fopen:NEAR
EXTRN	_XmsUnlockExtendedMemory:NEAR
EXTRN	__close:NEAR
EXTRN	_NoPPFS:WORD
_BSS      SEGMENT
COMM NEAR	_BootArgs:	BYTE:	 170
COMM NEAR	_usBlockHandle:	BYTE:	 2
_BSS      ENDS
EXTRN	__iob:BYTE
_DATA      SEGMENT
$S519_BootHeader	DB	0aaH
	DB	055H
	DB	055H
	DB	0aaH
	DB	00H
	DB	00H
$S520_BootTail	DB	05aH
	DB	0a5H
	DB	0aH
	DB	01aH
_BaudTable	DD	02580H
	DB	0cH
 	DB	1 DUP(0)

	DD	04b00H
	DB	06H
 	DB	1 DUP(0)

	DD	09600H
	DB	03H
 	DB	1 DUP(0)

	DD	0e100H
	DB	02H
 	DB	1 DUP(0)

	DD	01c200H
	DB	01H
 	DB	1 DUP(0)

_bSerialDownload	DW	00H
_iDesiredMode	DW	00H
$SG610	DB	'300STD.bin',  00H
$SG638	DB	'Invalid option - %s',  0aH,  00H
$SG645	DB	'Unsupported baud rate - %s',  0aH,  00H
$SG649	DB	'Invalid option - %s',  0aH,  00H
$SG653	DB	'Invalid option - %s',  0aH,  00H
$SG656	DB	'The /E and /K options are mutually exclusive - please choose'
	DB	' one of them.',  0dH,  0aH,  00H
$SG658	DB	'Invalid option - %s',  0aH,  00H
$SG661	DB	'The /E and /K options are mutually exclusive- please choose '
	DB	'one of them.',  0dH,  0aH,  00H
$SG663	DB	'Invalid option - %s',  0aH,  00H
$SG666	DB	'Invalid option - %s',  0aH,  00H
$SG669	DB	'Invalid option - %s',  0aH,  00H
$SG681	DB	'*.*',  00H
$SG690	DB	'Error source path missing',  0aH,  00H
$SG694	DB	'Unrecognized option - %s',  0aH,  00H
$SG699	DB	'HIMEM.SYS must be loaded',  0aH,  00H
$SG702	DB	'Error querying A20 status - %s',  0aH,  00H
$SG704	DB	'Warning A20 line already enabled',  0aH,  00H
$SG707	DB	'Can''t enable A20 line, error = 0x%4.4X',  0aH,  00H
$SG715	DB	'Jumping to 0x%8.8lX',  0aH,  00H
$SG717	DB	0aH,  0aH, '             ==============Press any key to canc'
	DB	'el==============',  0aH, ' ',  00H
$SG724	DB	0aH, '%s: Loads a BIN image into memory and boots it.',  0aH
	DB	0aH, 'Usage:%s /B:baud /C:Port /D:display /P /H /V /N:name',  0aH
	DB	'  (/E|/K):IO:IRQ[:<dotted IP>] /L:VXxVYxBPP[:PXxPY] <file na'
	DB	'me>',  0aH,  0aH, '  /B  Baud Rate [9600|19200|38400(default'
	DB	')|57600|115200]',  0aH, '  /C  Communications Port [0=disabl'
	DB	'e|1|2|3|4]',  0aH, '  /D  Display Resolution (for VESA modes'
	DB	', use the /L option instead).',  0aH, '      0 = 320x200x256'
	DB	' (default), 1 = 480x240x256,',  0aH, '      2 = 640x480x256,'
	DB	' 3 = 800x600x256, 4 = 1024x768x256',  0aH, '      5 = 240x32'
	DB	'0x256, 6 = 208x240x256',  0aH,  0aH, '  /P  Parallel port bo'
	DB	'ot download.',  0aH,  0aH, '  /A  Use permanent storage devi'
	DB	'ce to store NK image.',  0aH,  0aH, '  /H  Help - displays t'
	DB	'his message.',  0aH,  0aH, '  Default <file name> is NK.BIN '
	DB	'except for /P option which uses',  0aH, '  default on host u'
	DB	'nless <file name> specified.',  0aH,  0aH, 'Press any key fo'
	DB	'r more options...',  00H
$SG725	DB	0aH,  0aH,  0aH, 'Usage:%s /B:baud /C:Port /D:display /P /H '
	DB	'/V /N:name',  0aH, '  (/E|/K):IO:IRQ[:<dotted IP>] /L:VXxVYx'
	DB	'BPP[:PXxPY] <file name>',  0aH,  0aH, '  /V  Verbose - displ'
	DB	'ays extra status information during boot.',  0aH,  0aH, '  /'
	DB	'E:IO:IRQ[:<dotted IP>]  (Debug Ethernet Card parameters)',  0aH
	DB	'      IO - IO Base Address (specified in hexadecimal)',  0aH
	DB	'      IRQ - Interrupt (specified in decimal or hexadecimal)',  0aH
	DB	'      Dotted IP - (optional) static IP address (No DHCP)',  0aH
	DB	'    NOTE: The /E and /K options are mutually exclusive.',  0aH
	DB	0aH, '  /K:IO:IRQ[:<dotted IP>]  (RNDIS Card parameters)',  0aH
	DB	'      IO - IO Base Address (specified in hexadecimal)',  0aH
	DB	'      IRQ - Interrupt (specified in decimal or hexadecimal)',  0aH
	DB	'      Dotted IP - (optional) static IP address (No DHCP)',  0aH
	DB	'    NOTE: The /E and /K options are mutually exclusive.',  0aH
	DB	0aH, '  /L:DXxDYxBPP[:PXxPY] (Use VESA VBE Linear/Flat Frame'
	DB	'buffer video mode)',  0aH, '      DX, DY  - Display X and Y '
	DB	'Sizes',  0aH, '      BPP - Bits Per Pixel Color Depth (8, 16'
	DB	', 24, or 32)',  0aH, '      PX, PY  - (optional) Physical Sc'
	DB	'reen X and Y Sizes to simulate a',  0aH, '                sm'
	DB	'all device display (PX & PY should be greater than DX & DY).'
	DB	0aH, ' /N:name  Optionally specify a device name to be used '
	DB	'when creating',  0aH, '          the Ethernet debug name (fo'
	DB	'r host-side connectivity).',  0aH,  0aH, 'Press any key for '
	DB	'more options...',  00H
$SG726	DB	0aH, 'Usage: %s -s[:]<pattern> -(g|r|u)[[:]<pattern> [<desti'
	DB	'nation>]',  0aH, '-s    Show a directory of files matching <'
	DB	'pattern>.',  0aH,  0aH, '-g    Get files matching <pattern> '
	DB	'and copy them to the',  0aH, '      optionally specified <de'
	DB	'stination>.  Any existing file with',  0aH, '      the same '
	DB	'name will be overwritten.',  0aH,  0aH, '-r    Refresh files'
	DB	' matching <pattern> which already exist in <destination>',  0aH
	DB	'      and have a timestamp newer than the one in <destinatio'
	DB	'n>.',  0aH,  0aH, '-u    Update files matching <pattern> whi'
	DB	'ch don''t already exist in',  0aH, '      <destination> or t'
	DB	'hose that have a timestamp newer than those',  0aH, '      i'
	DB	'n <destination>.',  0aH,  0aH, '<pattern> Windows filename p'
	DB	'ath with optional wildcard characters.',  0aH,  0aH, '<desti'
	DB	'nation> If not specified then the current directory is the d'
	DB	'efault.',  0aH, '      If specified and it doesn''t exist an'
	DB	'd the last character is \,',  0aH, '      then the directory'
	DB	' is created.  Otherwise <destination> is',  0aH, '      trea'
	DB	'ted as the name of the file.',  0aH, '      It is an error f'
	DB	'or <pattern> to match multiple files',  0aH, '      when <de'
	DB	'stination> specifies a file.',  0aH, 'For CE Collections - L'
	DB	'ast built with ver.2.01-Beta1-03',  00H
	ORG	$+1
$S777_?ucSignature@?1??LoadImage@@9@9	DB	042H
	DB	030H
	DB	030H
	DB	030H
	DB	046H
	DB	046H
	DB	0aH
$SG787	DB	0dH, '                                                      '
	DB	'                   ',  0dH,  0aH, '        ',  00H
$SG789	DB	'Error querying free extended memory - %s',  0aH,  00H
$SG791	DB	'               ImageName:......: %s',  0aH,  00H
$SG792	DB	'               FLATMode........: %d',  0aH,  00H
$SG793	DB	'               VESAMode........: 0x%x',  0aH,  00H
$SG794	DB	'               FreeEMSMem......: %u',  0aH,  00H
$SG795	DB	'               LagestBlock.....: %u',  0aH,  00H
$SG796	DB	'             ==========Booting - Press CTRL+C to cancel====='
	DB	'====',  0aH, ' ',  00H
$SG797	DB	'                            ',  00H
$SG798	DB	'             ',  00H
$SG800	DB	'Total free extended memory = %u, largest block = %u',  0aH,  00H
$SG802	DB	'Error allocating extended memory - %s',  0aH,  00H
$SG805	DB	'Error locking extended memory - %s',  0aH,  00H
$SG808	DB	'Block allocated at 0x%lX',  0aH,  00H
$SG815	DB	'Error zeroing extended memory - %s',  0aH,  00H
$SG825	DB	'Loading image %s via serial port.',  0dH,  0aH,  00H
$SG827	DB	'Loading image %s via parallel port.',  0dH,  0aH,  00H
$SG833	DB	'Loading host default image via serial port.',  0dH,  0aH,  00H
$SG835	DB	'Loading host default image via parallel port.',  0dH,  0aH,  00H
$SG850	DB	'Sending boot packet: ',  00H
$SG856	DB	'%x ',  00H
$SG860	DB	'Sent.',  0dH,  0aH,  00H
$SG863	DB	'%s: Error opening file - %s',  0aH,  00H
$SG865	DB	'%s: Error obtaining file size - %s',  0aH,  00H
$SG868	DB	'Loading %s, size = %ld',  0aH,  00H
$SG870	DB	'Error reading signature - %s',  0aH,  00H
$SG873	DB	'Error invalid signature',  0aH, 'Data: ',  00H
$SG877	DB	'%x ',  00H
$SG878	DB	0dH,  0aH,  00H
$SG881	DB	'Image physical start = 0x%8.8lX, size = %ld',  0aH,  00H
$SG882	DB	00H
$SG887	DB	'Error reading header - %s',  0aH,  00H
$SG892	DB	'Error image section doesn''t fit in allocated block',  0aH, ' '
	DB	'     Block allocated at 0x%lX, size = %ld',  0aH, '      Sec'
	DB	'tion physical start = 0x%8.8lX, size = %ld',  0aH, '      Me'
	DB	'mory too low in your VM might cause this.',  0aH,  0aH, '   '
	DB	'     >> Increase memory may fix this.',  0aH,  00H
$SG895	DB	'Section physical start = 0x%8.8lX, size = %ld',  0aH,  00H
$SG902	DB	'Error reading section - %s',  0aH,  00H
$SG905	DB	'Error moving extended memory - %s',  0aH,  00H
$SG914	DB	'PCI bus not detected',  0aH,  00H
$SG925	DB	'Read Packet Failed',  0aH,  00H
$SG928	DB	'Read Header/Tail failed',  0aH,  00H
$SG931	DB	'Invalid Command',  0aH,  00H
$SG933	DB	'Invalid Length',  0aH,  00H
$SG938	DB	'Invalid checksum',  0aH,  00H
$SG943	DB	'$@(',  00H
$SG953	DB	'rb',  00H
$SG967	DB	'Booting %s compiled with Windows CE Version %d',  0aH,  00H
$SG969	DB	'%s: Unknown or old version of bootloader',  0aH,  00H
_DATA      ENDS
_BSS      SEGMENT
$S775_?ucBuffer@?1??LoadImage@@9@9	DW 04000H DUP (?)
_BSS      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	PUBLIC	_main
_main	PROC NEAR
;|*** //
;|*** // Copyright (c) Microsoft Corporation.  All rights reserved.
;|*** //
;|*** //
;|*** // Use of this source code is subject to the terms of the Microsoft end-user
;|*** // license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
;|*** // If you did not accept the terms of the EULA, you are not authorized to use
;|*** // this source code. For a copy of the EULA, please see the LICENSE.RTF on your
;|*** // install media.
;|*** //
;|*** 
;|*** /*++
;|*** THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
;|*** ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
;|*** THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
;|*** PARTICULAR PURPOSE.
;|*** 
;|*** Module Name:    main.c
;|*** 
;|*** Abstract:       This program, loadcepc.exe, is responsible for loading
;|***                 a binary image into memory and booting the image. It 
;|***                 processes the boot arguments, loads the image file, and 
;|***                 then executes it.
;|*** 
;|*** Functions:
;|*** 
;|*** 
;|*** Notes:          none
;|*** 
;|*** --*/
;|*** 
;|*** // Include Files
;|*** 
;|*** #include <conio.h>
;|*** #include <fcntl.h>
;|*** #include <io.h>
;|*** #include <stdio.h>
;|*** #include <stdlib.h>
;|*** #include <string.h>
;|*** #include <signal.h>
;|*** #include "loadcepc.h"
;|*** #include "xmsapi.h"
;|*** #include "ethernet.h"
;|*** #include <bootarg.h>
;|*** 
;|*** 
;|*** // Externs
;|*** 
;|*** extern int NoPPFS;                      // parallel port not present flag
;|*** 
;|*** 
;|*** // Defines
;|*** 
;|*** #define CHUNKSIZE                   (32768)
;|*** #define COPY_FLAG_UPDATE_EXISTING   (0x0001)
;|*** #define COPY_FLAG_UPDATE_OR_ADD     (0x0002)
;|*** 
;|*** 
;|*** // Variables
;|*** 
;|*** // Boot Header
;|*** 
;|*** static const unsigned char BootHeader[] = 
;|*** {
;|***     0xAA,                               // header = 4 bytes
;|***     0x55,
;|***     0x55,
;|***     0xAA,
;|***     0x00,                               // opcode = 2 bytes (0 = BOOT)
;|***     0x00,
;|*** };
;|*** 
;|*** #define BOOT_HEADER_SIZE (sizeof(BootHeader) / sizeof(BootHeader[0]))
;|*** 
;|*** 
;|*** // Boot Trailer
;|*** 
;|*** static const unsigned char BootTail[] = 
;|*** {
;|***     0x5A,                               // trail = 4 bytes
;|***     0xA5,
;|***     0x0A,
;|***     0x1A
;|*** };
;|*** 
;|*** #define BOOT_TAIL_SIZE (sizeof(BootTail) / sizeof(BootTail[0]))
;|*** 
;|*** #define BOOT_TYPE (-4)                   // boot type for x86
;|*** 
;|*** 
;|*** // Baud Rate
;|*** 
;|*** struct
;|*** {
;|***     ULONG   ulRate;
;|***     UCHAR   ucDivisor;
;|*** }   
;|*** BaudTable[] =
;|*** {
;|***     { 9600,  12},
;|***     { 19200,  6},
;|***     { 38400,  3},
;|***     { 57600,  2},
;|***     { 115200, 1}
;|*** };
;|*** 
;|*** #define NUM_BAUD_RATES  (sizeof(BaudTable) / sizeof(BaudTable[0]))
;|*** 
;|*** 
;|*** BOOT_ARGS   BootArgs;
;|*** USHORT      usBlockHandle;                  // XMS memory handle
;|*** BOOL        bSerialDownload=FALSE;
;|*** 
;|*** 
;|*** // Function Prototypes
;|*** 
;|*** // External Functions
;|*** 
;|*** void    OEMInitDebugSerial(void);
;|*** int     OEMReadDebugByte(void);
;|*** void    OEMReadDebugBytes(unsigned char * ucBuffer, int usReadSize);
;|*** void    OEMWriteDebugByte(unsigned char ch);
;|*** int     OEMParallelPortGetByte(void);
;|*** void    OEMParallelPortSendByte(UCHAR chData);
;|*** void    OEMParallelPortInit(void);
;|*** void    Launch( ULONG ulEntryPoint, ULONG ulArguments );
;|*** 
;|*** // in video.c
;|*** 
;|*** UCHAR   SetVideoMode( int iDesiredMode);
;|*** BOOL    ParseVESAOptions( char * params);
;|*** 
;|*** // in ethmain.c
;|*** 
;|*** BOOL    ParseEthernetOptions( char * argstr);
;|*** BOOL    ParseDeviceName( char * argstr);
;|*** 
;|*** // in ppfstool.c
;|*** 
;|*** void    DrawPercent( DWORD CurValue, DWORD MaxValue);
;|*** void    DisplayDirectory( char *pszPath);
;|*** void    GetFile( char *pszSource, char *pszDestination, USHORT usCopyFlags);
;|*** 
;|*** // Local Functions
;|*** 
;|*** static void         usage( char *pszProgramNameArg );
;|*** static void         ExitSigHandler( int sig );
;|*** static WORD         GetJumpFlags( void );
;|*** static UCHAR        GetPCIConfigMechanism();
;|*** static USHORT       DownloadRead( int     hImage, 
;|***                                   UCHAR  *ucBuffer, 
;|***                                   USHORT  usReadSize, 
;|***                                   BOOL    bParallelDownload );
;|*** static int          LoadImage   ( BOOL bVerbose, 
;|***                                   BOOL bParallelDownload, 
;|***                                   char *pszFileName, 
;|***                                   PULONG pulEntryAddress);
;|*** static void	DisplayCEOSVersion( char *pszFileName);
;|*** 
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Function Name:  main( int argc, char **argv )
;|*** //  Description..:  Main entry point. 
;|*** //  Inputs.......:  argc, argv      
;|*** //  Outputs......:  int             exit status
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** int     iDesiredMode = 0;
;|*** int main( int argc, char **argv )
;|*** {
; Line 172
	*** 000000	c8 2c 00 00 		enter	44,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	pszFileName = -2
;	ulEntryPoint = -6
;	ulArguments = -10
;	xmsError = -12
;	bEnabled = -14
;	bVerbose = -16
;	bParallelDownload = -18
;	bBackupImage = -20
;	ulBaudRate = -24
;	cOption = -26
;	i = -28
;	ret = -30
;	iPpfstool = -32
;	bRNDISDownload = -34
;	bEtherDownload = -36
;	argv = 6
;	argc = 4
;|***     char *  pszFileName = "300STD.bin";
; Line 173
	*** 000006	c7 46 fe 00 00 		mov	WORD PTR [bp-2],OFFSET DGROUP:$SG610	;pszFileName
;|***     ULONG   ulEntryPoint;
;|***     ULONG   ulArguments;
;|***     int     xmsError;
;|***     BOOL    bEnabled;
;|***     BOOL    bVerbose = FALSE;
;|***     BOOL    bParallelDownload=FALSE;
;|***     BOOL    bBackupImage=FALSE;
;|***     ULONG   ulBaudRate;
;|***     char    cOption;
;|***     int     i = 0;
;|***     int     ret = 0;
;|***     int     iPpfstool=0;
;|***     BOOL    bRNDISDownload=FALSE;
;|***     BOOL    bEtherDownload=FALSE;
; Line 187
	*** 00000b	33 c0 			xor	ax,ax
	*** 00000d	89 46 f0 		mov	WORD PTR [bp-16],ax	;bVerbose
	*** 000010	89 46 ee 		mov	WORD PTR [bp-18],ax	;bParallelDownload
	*** 000013	89 46 ec 		mov	WORD PTR [bp-20],ax	;bBackupImage
	*** 000016	89 46 e4 		mov	WORD PTR [bp-28],ax	;i
	*** 000019	89 46 e2 		mov	WORD PTR [bp-30],ax	;ret
	*** 00001c	89 46 e0 		mov	WORD PTR [bp-32],ax	;iPpfstool
	*** 00001f	89 46 de 		mov	WORD PTR [bp-34],ax	;bRNDISDownload
	*** 000022	89 46 dc 		mov	WORD PTR [bp-36],ax	;bEtherDownload
;|*** 
;|***     // Setup signal handler for Ctrl+C/Ctrl+Break
;|*** 
;|***     signal( SIGINT,  ExitSigHandler );
; Line 191
	*** 000025	68 00 00 		push	OFFSET ExitSigHandler
	*** 000028	6a 02 			push	2
	*** 00002a	e8 00 00 		call	_signal
	*** 00002d	83 c4 04 		add	sp,4
;|***     signal( SIGTERM, ExitSigHandler );
; Line 192
	*** 000030	68 00 00 		push	OFFSET ExitSigHandler
	*** 000033	6a 0f 			push	15	;000fH
	*** 000035	e8 00 00 		call	_signal
	*** 000038	83 c4 04 		add	sp,4
;|***     signal( SIGABRT, ExitSigHandler );
; Line 193
	*** 00003b	68 00 00 		push	OFFSET ExitSigHandler
	*** 00003e	6a 16 			push	22	;0016H
	*** 000040	e8 00 00 		call	_signal
	*** 000043	83 c4 04 		add	sp,4
;|*** 
;|***     // Initialize the boot args block
;|*** 
;|***     memset( &BootArgs, 0, sizeof(BOOT_ARGS));
; Line 197
	*** 000046	33 c0 			xor	ax,ax
	*** 000048	bb 00 00 		mov	bx,OFFSET DGROUP:_BootArgs
	*** 00004b	b9 55 00 		mov	cx,85	;0055H
	*** 00004e	8b fb 			mov	di,bx
	*** 000050	1e 			push	ds
	*** 000051	07 			pop	es
	*** 000052	f3 			rep
	*** 000053	ab 			stosw
;|***     BootArgs.ucVideoMode     = 0;
;|***     BootArgs.ucComPort       = 1;
; Line 199
	*** 000054	c6 06 01 00 01 		mov	BYTE PTR _BootArgs+1,1
;|***     BootArgs.ucBaudDivisor   = 3;           // Default 38400
; Line 200
	*** 000059	c6 06 02 00 03 		mov	BYTE PTR _BootArgs+2,3
;|***     BootArgs.ucPCIConfigType = 0;
; Line 201
	*** 00005e	a2 00 00 		mov	BYTE PTR _BootArgs,al
	*** 000061	a2 03 00 		mov	BYTE PTR _BootArgs+3,al
;|***     BootArgs.dwSig           = BOOTARG_SIG;
; Line 202
	*** 000064	c7 06 04 00 42 4f 	mov	WORD PTR _BootArgs+4,20290	;4f42H
	*** 00006a	c7 06 06 00 4f 54 	mov	WORD PTR _BootArgs+6,21583	;544fH
;|***     BootArgs.dwLen           = sizeof(BOOT_ARGS);
; Line 203
	*** 000070	c7 06 08 00 aa 00 	mov	WORD PTR _BootArgs+8,170	;00aaH
	*** 000076	a3 0a 00 		mov	WORD PTR _BootArgs+10,ax
;|***     BootArgs.dwVersionSig    = BOOT_ARG_VERSION_SIG;
; Line 204
	*** 000079	c7 06 80 00 78 56 	mov	WORD PTR _BootArgs+128,22136	;5678H
	*** 00007f	c7 06 82 00 34 12 	mov	WORD PTR _BootArgs+130,4660	;1234H
;|***     BootArgs.MajorVersion    = BOOT_ARG_MAJOR_VER;
; Line 205
	*** 000085	c7 06 84 00 01 00 	mov	WORD PTR _BootArgs+132,1
;|***     BootArgs.MinorVersion    = BOOT_ARG_MINOR_VER;
;|*** 
;|***     usBlockHandle = 0;
; Line 208
	*** 00008b	a3 86 00 		mov	WORD PTR _BootArgs+134,ax
	*** 00008e	a3 00 00 		mov	WORD PTR _usBlockHandle,ax
;|*** 
;|***     // Initialize parallel port
;|*** 
;|***     OEMParallelPortInit();              
; Line 212
	*** 000091	e8 00 00 		call	_OEMParallelPortInit
;|*** 
;|***     // Process arguments 
;|*** 
;|***     if( argc > 1 )
; Line 216
	*** 000094	83 7e 04 01 		cmp	WORD PTR [bp+4],1	;argc
	*** 000098	7f 03 			jg	$JCC152
	*** 00009a	e9 dd 03 		jmp	$I696
					$JCC152:
;|***     {
; Line 217
;	iArgIndex = -38
;|***         int iArgIndex;
;|*** 
;|***         for( iArgIndex = 1; iArgIndex < argc; iArgIndex++ )
; Line 220
	*** 00009d	c7 46 da 01 00 		mov	WORD PTR [bp-38],1	;iArgIndex
	*** 0000a2	e9 a0 03 		jmp	$F627
	*** 0000a5	90 			nop	
;|***         {
;|***             if( argv[iArgIndex][0] != '/' && argv[iArgIndex][0] != '-' )
;|***             {
;|***                 break;
;|***             }
;|*** 
;|***             cOption = (char)tolower(argv[iArgIndex][1]);
; Line 227
					$I630:
;|*** 
;|***             // Process according to option character
;|*** 
;|***             switch( cOption )
; Line 231
	*** 0000a6	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 0000a9	03 db 			add	bx,bx
	*** 0000ab	8b 18 			mov	bx,WORD PTR [bx][si]
	*** 0000ad	8a 47 01 		mov	al,BYTE PTR [bx+1]
	*** 0000b0	98 			cbw	
	*** 0000b1	50 			push	ax
	*** 0000b2	e8 00 00 		call	_tolower
	*** 0000b5	83 c4 02 		add	sp,2
	*** 0000b8	88 46 e6 		mov	BYTE PTR [bp-26],al	;cOption
	*** 0000bb	98 			cbw	
	*** 0000bc	3d 76 00 		cmp	ax,118	;0076H
	*** 0000bf	75 03 			jne	$JCC191
	*** 0000c1	e9 10 02 		jmp	$SC673
					$JCC191:
	*** 0000c4	76 03 			jbe	$JCC196
	*** 0000c6	e9 32 03 		jmp	$SD693
					$JCC196:
	*** 0000c9	3c 68 			cmp	al,104	;0068H
	*** 0000cb	75 03 			jne	$JCC203
	*** 0000cd	e9 3e 03 		jmp	$SC695
					$JCC203:
	*** 0000d0	7e 03 			jle	$JCC208
	*** 0000d2	e9 47 03 		jmp	$L974
					$JCC208:
	*** 0000d5	3c 63 			cmp	al,99	;0063H
	*** 0000d7	75 03 			jne	$JCC215
	*** 0000d9	e9 ac 00 		jmp	$SC646
					$JCC215:
	*** 0000dc	7e 03 			jle	$JCC220
	*** 0000de	e9 05 03 		jmp	$L975
					$JCC220:
	*** 0000e1	2c 3f 			sub	al,63	;003fH
	*** 0000e3	75 03 			jne	$JCC227
	*** 0000e5	e9 26 03 		jmp	$SC695
					$JCC227:
	*** 0000e8	2c 22 			sub	al,34	;0022H
	*** 0000ea	75 03 			jne	$JCC234
	*** 0000ec	e9 cf 01 		jmp	$SC671
					$JCC234:
	*** 0000ef	fe c8 			dec	al
	*** 0000f1	74 03 			je	$JCC241
	*** 0000f3	e9 05 03 		jmp	$SD693
					$JCC241:
;|***             {
;|***             case 'b':   /* Baud rate */
;|*** 
;|***                 if( argv[iArgIndex][2] != ':' ||
;|***                     argv[iArgIndex][3] < '0' || argv[iArgIndex][3] > '9' )
; Line 236
	*** 0000f6	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 0000f9	03 db 			add	bx,bx
	*** 0000fb	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 0000fe	8b 18 			mov	bx,WORD PTR [bx][si]
	*** 000100	80 7f 02 3a 		cmp	BYTE PTR [bx+2],58	;003aH
	*** 000104	75 0c 			jne	$I637
	*** 000106	80 7f 03 30 		cmp	BYTE PTR [bx+3],48	;0030H
	*** 00010a	7c 06 			jl	$I637
	*** 00010c	80 7f 03 39 		cmp	BYTE PTR [bx+3],57	;0039H
	*** 000110	7e 18 			jle	$I636
					$I637:
;|***                 {
;|***                     printf("Invalid option - %s\n", argv[iArgIndex]);
; Line 238
	*** 000112	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 000115	03 db 			add	bx,bx
	*** 000117	ff 30 			push	WORD PTR [bx][si]
	*** 000119	68 00 00 		push	OFFSET DGROUP:$SG638
					$L998:
	*** 00011c	e8 00 00 		call	_printf
	*** 00011f	83 c4 04 		add	sp,4
;|***                     ret = 1;
; Line 239
					$L997:
	*** 000122	c7 46 e2 01 00 		mov	WORD PTR [bp-30],1	;ret
;|***                     goto main_error;
; Line 240
	*** 000127	e9 be 04 		jmp	$main_error639
;|***                 }
;|*** 
;|***                 ulBaudRate = atol(&argv[iArgIndex][3]);
; Line 243
					$I636:
	*** 00012a	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 00012d	03 db 			add	bx,bx
	*** 00012f	8b 00 			mov	ax,WORD PTR [bx][si]
	*** 000131	05 03 00 		add	ax,3
	*** 000134	50 			push	ax
	*** 000135	e8 00 00 		call	_atol
	*** 000138	83 c4 02 		add	sp,2
	*** 00013b	89 46 e8 		mov	WORD PTR [bp-24],ax	;ulBaudRate
	*** 00013e	89 56 ea 		mov	WORD PTR [bp-22],dx
;|*** 
;|***                 for( i=0; i < NUM_BAUD_RATES; i++ )
; Line 245
	*** 000141	c7 46 e4 00 00 		mov	WORD PTR [bp-28],0	;i
	*** 000146	eb 03 			jmp	SHORT $F640
;|***                 {
;|***                     if( BaudTable[i].ulRate == ulBaudRate )
;|***                     {
;|***                         BootArgs.ucBaudDivisor = BaudTable[i].ucDivisor;
;|***                         break;
;|***                     }
;|***                 }
; Line 252
					$FC641:
	*** 000148	ff 46 e4 		inc	WORD PTR [bp-28]	;i
					$F640:
	*** 00014b	83 7e e4 05 		cmp	WORD PTR [bp-28],5	;i
	*** 00014f	73 1e 			jae	$FB642
;|***                     if( BaudTable[i].ulRate == ulBaudRate )
; Line 247
	*** 000151	8b 5e e4 		mov	bx,WORD PTR [bp-28]	;i
	*** 000154	8b cb 			mov	cx,bx
	*** 000156	03 db 			add	bx,bx
	*** 000158	03 d9 			add	bx,cx
	*** 00015a	03 db 			add	bx,bx
	*** 00015c	39 87 00 00 		cmp	WORD PTR _BaudTable[bx],ax
	*** 000160	75 e6 			jne	$FC641
	*** 000162	39 97 02 00 		cmp	WORD PTR _BaudTable[bx+2],dx
	*** 000166	75 e0 			jne	$FC641
;|***                     {
;|***                         BootArgs.ucBaudDivisor = BaudTable[i].ucDivisor;
; Line 249
	*** 000168	8a 87 04 00 		mov	al,BYTE PTR _BaudTable[bx+4]
	*** 00016c	a2 02 00 		mov	BYTE PTR _BootArgs+2,al
;|***                         break;
; Line 250
					$FB642:
;|***                     }
;|***                 }
;|*** 
;|***                 if( i >= NUM_BAUD_RATES )
; Line 254
	*** 00016f	83 7e e4 05 		cmp	WORD PTR [bp-28],5	;i
	*** 000173	73 03 			jae	$JCC371
	*** 000175	e9 ca 02 		jmp	$SB632
					$JCC371:
;|***                 {
;|***                     printf( "Unsupported baud rate - %s\n", argv[iArgIndex] );
; Line 256
	*** 000178	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 00017b	03 db 			add	bx,bx
	*** 00017d	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000180	ff 30 			push	WORD PTR [bx][si]
	*** 000182	68 00 00 		push	OFFSET DGROUP:$SG645
	*** 000185	eb 95 			jmp	SHORT $L998
	*** 000187	90 			nop	
					$SC646:
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 break;
;|*** 
;|***             case 'c':
;|*** 
;|***                 // COM Port Parameter
;|***                 //
;|***                 // Allowable values for the COM ports 1-4. Zero (0) is 
;|***                 // allowed as a way to disable use of the COM port and is
;|***                 // allowed by ...\csp\i486\oal\debug.c.
;|*** 
;|***                 if( (argv[iArgIndex][2] == ':') &&
;|***                     (argv[iArgIndex][3] >= '0') &&  
;|***                     (argv[iArgIndex][3] <= '4') )
; Line 272
	*** 000188	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 00018b	03 db 			add	bx,bx
	*** 00018d	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000190	8b 18 			mov	bx,WORD PTR [bx][si]
	*** 000192	80 7f 02 3a 		cmp	BYTE PTR [bx+2],58	;003aH
	*** 000196	75 18 			jne	$I647
	*** 000198	80 7f 03 30 		cmp	BYTE PTR [bx+3],48	;0030H
	*** 00019c	7c 12 			jl	$I647
	*** 00019e	80 7f 03 34 		cmp	BYTE PTR [bx+3],52	;0034H
	*** 0001a2	7f 0c 			jg	$I647
;|***                 {
;|***                     BootArgs.ucComPort = (UCHAR)(argv[iArgIndex][3] - '0');
; Line 274
	*** 0001a4	8a 47 03 		mov	al,BYTE PTR [bx+3]
	*** 0001a7	2c 30 			sub	al,48	;0030H
	*** 0001a9	a2 01 00 		mov	BYTE PTR _BootArgs+1,al
;|***                 }
;|***                 else
;|***                 {
;|***                     printf( "Invalid option - %s\n", argv[iArgIndex] );
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 break;
; Line 282
	*** 0001ac	e9 93 02 		jmp	$SB632
	*** 0001af	90 			nop	
					$I647:
;|***                     printf( "Invalid option - %s\n", argv[iArgIndex] );
; Line 278
	*** 0001b0	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 0001b3	03 db 			add	bx,bx
	*** 0001b5	ff 30 			push	WORD PTR [bx][si]
	*** 0001b7	68 00 00 		push	OFFSET DGROUP:$SG649
	*** 0001ba	e9 5f ff 		jmp	$L998
	*** 0001bd	90 			nop	
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 break;
;|*** 
;|***             case 'd':   /* Display mode */
; Line 284
					$SC650:
;|*** 
;|***                 if( argv[iArgIndex][2] != ':' ||
;|***                     argv[iArgIndex][3] < '0' || argv[iArgIndex][3] > '6' )
; Line 287
	*** 0001be	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 0001c1	03 db 			add	bx,bx
	*** 0001c3	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 0001c6	8b 18 			mov	bx,WORD PTR [bx][si]
	*** 0001c8	80 7f 02 3a 		cmp	BYTE PTR [bx+2],58	;003aH
	*** 0001cc	75 0c 			jne	$I652
	*** 0001ce	80 7f 03 30 		cmp	BYTE PTR [bx+3],48	;0030H
	*** 0001d2	7c 06 			jl	$I652
	*** 0001d4	80 7f 03 36 		cmp	BYTE PTR [bx+3],54	;0036H
	*** 0001d8	7e 0e 			jle	$I651
					$I652:
;|***                 {
;|***                     printf( "Invalid option - %s\n", argv[iArgIndex] );
; Line 289
	*** 0001da	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 0001dd	03 db 			add	bx,bx
	*** 0001df	ff 30 			push	WORD PTR [bx][si]
	*** 0001e1	68 00 00 		push	OFFSET DGROUP:$SG653
	*** 0001e4	e9 35 ff 		jmp	$L998
	*** 0001e7	90 			nop	
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 iDesiredMode = (int)(argv[iArgIndex][3] - '0');
; Line 293
					$I651:
	*** 0001e8	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 0001eb	03 db 			add	bx,bx
	*** 0001ed	8b 18 			mov	bx,WORD PTR [bx][si]
	*** 0001ef	8a 47 03 		mov	al,BYTE PTR [bx+3]
	*** 0001f2	98 			cbw	
	*** 0001f3	2d 30 00 		sub	ax,48	;0030H
	*** 0001f6	e9 92 00 		jmp	$L1000
	*** 0001f9	90 			nop	
;|***                 break;
;|*** 
;|***             case 'e':
; Line 296
					$SC654:
;|***                 if( bRNDISDownload )
; Line 297
	*** 0001fa	83 7e de 00 		cmp	WORD PTR [bp-34],0	;bRNDISDownload
	*** 0001fe	74 0c 			je	$I655
;|***                 {
;|***                     printf( "The /E and /K options are mutually exclusive"
;|***                             " - please choose one of them.\r\n" );
; Line 300
	*** 000200	68 00 00 		push	OFFSET DGROUP:$SG656
					$L999:
	*** 000203	e8 00 00 		call	_printf
	*** 000206	83 c4 02 		add	sp,2
;|*** 
;|***                     goto main_error;
; Line 302
	*** 000209	e9 dc 03 		jmp	$main_error639
;|***                 }
;|***                 if( !ParseEthernetOptions(argv[iArgIndex]) )
; Line 304
					$I655:
	*** 00020c	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 00020f	03 db 			add	bx,bx
	*** 000211	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000214	ff 30 			push	WORD PTR [bx][si]
	*** 000216	8b fb 			mov	di,bx
	*** 000218	e8 00 00 		call	_ParseEthernetOptions
	*** 00021b	83 c4 02 		add	sp,2
	*** 00021e	0b c0 			or	ax,ax
	*** 000220	75 0a 			jne	$I657
;|***                 {
;|***                     printf("Invalid option - %s\n", argv[iArgIndex]);
; Line 306
	*** 000222	03 fe 			add	di,si
	*** 000224	ff 35 			push	WORD PTR [di]
	*** 000226	68 00 00 		push	OFFSET DGROUP:$SG658
	*** 000229	e9 f0 fe 		jmp	$L998
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 bEtherDownload = TRUE;
; Line 310
					$I657:
	*** 00022c	c7 46 dc 01 00 		mov	WORD PTR [bp-36],1	;bEtherDownload
;|***                 break;
; Line 311
	*** 000231	e9 0e 02 		jmp	$SB632
;|*** 
;|***             case 'k':   /* RNDIS flags */
; Line 313
					$SC659:
;|*** 
;|***                 if( bEtherDownload )
; Line 315
	*** 000234	83 7e dc 00 		cmp	WORD PTR [bp-36],0	;bEtherDownload
	*** 000238	74 06 			je	$I660
;|***                 {
;|***                     printf( "The /E and /K options are mutually exclusive"
;|***                             "- please choose one of them.\r\n");
; Line 318
	*** 00023a	68 00 00 		push	OFFSET DGROUP:$SG661
	*** 00023d	eb c4 			jmp	SHORT $L999
	*** 00023f	90 			nop	
;|***                     goto main_error;
;|***                 }
;|***                 if( !ParseEthernetOptions(argv[iArgIndex]) )
; Line 321
					$I660:
	*** 000240	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 000243	03 db 			add	bx,bx
	*** 000245	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000248	ff 30 			push	WORD PTR [bx][si]
	*** 00024a	8b fb 			mov	di,bx
	*** 00024c	e8 00 00 		call	_ParseEthernetOptions
	*** 00024f	83 c4 02 		add	sp,2
	*** 000252	0b c0 			or	ax,ax
	*** 000254	75 0a 			jne	$I662
;|***                 {
;|***                     printf("Invalid option - %s\n", argv[iArgIndex]);
; Line 323
	*** 000256	03 fe 			add	di,si
	*** 000258	ff 35 			push	WORD PTR [di]
	*** 00025a	68 00 00 		push	OFFSET DGROUP:$SG663
	*** 00025d	e9 bc fe 		jmp	$L998
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 bRNDISDownload = TRUE;
; Line 327
					$I662:
	*** 000260	c7 46 de 01 00 		mov	WORD PTR [bp-34],1	;bRNDISDownload
;|***                 break;
; Line 328
	*** 000265	e9 da 01 		jmp	$SB632
;|*** 
;|***             case 'l':   
; Line 330
					$SC664:
;|*** 
;|***                 // VESA VBE Linear/Flat Framebuffer display mode 
;|*** 
;|***                 if( !ParseVESAOptions( argv[iArgIndex] ) )
; Line 334
	*** 000268	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 00026b	03 db 			add	bx,bx
	*** 00026d	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000270	ff 30 			push	WORD PTR [bx][si]
	*** 000272	8b fb 			mov	di,bx
	*** 000274	e8 00 00 		call	_ParseVESAOptions
	*** 000277	83 c4 02 		add	sp,2
	*** 00027a	0b c0 			or	ax,ax
	*** 00027c	75 0a 			jne	$I665
;|***                 {
;|***                     printf( "Invalid option - %s\n", argv[iArgIndex] );
; Line 336
	*** 00027e	03 fe 			add	di,si
	*** 000280	ff 35 			push	WORD PTR [di]
	*** 000282	68 00 00 		push	OFFSET DGROUP:$SG666
	*** 000285	e9 94 fe 		jmp	$L998
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 iDesiredMode = BootArgs.vesaMode;
; Line 340
					$I665:
	*** 000288	a1 6c 00 		mov	ax,WORD PTR _BootArgs+108
					$L1000:
	*** 00028b	a3 00 00 		mov	WORD PTR _iDesiredMode,ax
;|*** #if 0
;|*** 
;|***                 // Video Mode Debug - display and hang
;|*** 
;|***                 printf( "VESA Boot Options\n" );
;|***                 printf( "vesaMode........: 0x%x\n", BootArgs.vesaMode );
;|***                 printf( "xDisplayScreen..: %d\n", BootArgs.cxDisplayScreen );
;|***                 printf( "YDisplayScreen..: %d\n", BootArgs.cyDisplayScreen );
;|***                 printf( "bppScreen.......: %d\n", BootArgs.bppScreen );
;|***                 printf( "xPhysScreen.....: %d\n", BootArgs.cxPhysicalScreen );  
;|***                 printf( "yPhysScreen.....: %d\n", BootArgs.cyPhysicalScreen );  
;|*** 
;|***                 while( 1 )
;|***                 {
;|***                     ;
;|***                 }
;|*** #endif
;|***                 break;
; Line 358
	*** 00028e	e9 b1 01 		jmp	$SB632
	*** 000291	90 			nop	
;|*** 
;|***             case 'n':   /* Device name specified */
; Line 360
					$SC667:
;|*** 
;|***                 if( !ParseDeviceName(argv[iArgIndex]) )
; Line 362
	*** 000292	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 000295	03 db 			add	bx,bx
	*** 000297	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 00029a	ff 30 			push	WORD PTR [bx][si]
	*** 00029c	8b fb 			mov	di,bx
	*** 00029e	e8 00 00 		call	_ParseDeviceName
	*** 0002a1	83 c4 02 		add	sp,2
	*** 0002a4	0b c0 			or	ax,ax
	*** 0002a6	74 03 			je	$JCC678
	*** 0002a8	e9 97 01 		jmp	$SB632
					$JCC678:
;|***                 {
;|***                     printf("Invalid option - %s\n", argv[iArgIndex]); 
; Line 364
	*** 0002ab	03 fe 			add	di,si
	*** 0002ad	ff 35 			push	WORD PTR [di]
	*** 0002af	68 00 00 		push	OFFSET DGROUP:$SG669
	*** 0002b2	e9 67 fe 		jmp	$L998
	*** 0002b5	90 			nop	
					$SC670:
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 break;
;|*** 
;|***             case 'p':   /* Parallel port boot download */
;|*** 
;|***                 bParallelDownload=TRUE;
; Line 372
	*** 0002b6	c7 46 ee 01 00 		mov	WORD PTR [bp-18],1	;bParallelDownload
	*** 0002bb	eb 0f 			jmp	SHORT $L1001
	*** 0002bd	90 			nop	
;|***                 pszFileName= NULL;
;|***                 break;
;|*** 
;|***             case 'a':   /* Use permanent storage to store image */
; Line 376
					$SC671:
;|*** 
;|***                 bBackupImage=TRUE;
; Line 378
	*** 0002be	c7 46 ec 01 00 		mov	WORD PTR [bp-20],1	;bBackupImage
;|***                 break;
; Line 379
	*** 0002c3	e9 7c 01 		jmp	$SB632
;|*** 
;|***             case 'q':   /* Serial port boot download */
; Line 381
					$SC672:
;|*** 
;|***                 bSerialDownload=TRUE;
; Line 383
	*** 0002c6	c7 06 00 00 01 00 	mov	WORD PTR _bSerialDownload,1
;|***                 pszFileName= NULL;
; Line 384
					$L1001:
	*** 0002cc	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;pszFileName
;|***                 break;
; Line 385
	*** 0002d1	e9 6e 01 		jmp	$SB632
;|*** 
;|***             case 'v':
; Line 387
					$SC673:
;|*** 
;|***                 bVerbose = TRUE;
; Line 389
	*** 0002d4	c7 46 f0 01 00 		mov	WORD PTR [bp-16],1	;bVerbose
;|***                 break;
; Line 390
	*** 0002d9	e9 66 01 		jmp	$SB632
;|*** 
;|***             case 's':
; Line 392
					$SC674:
;|***                 {
; Line 393
;	pszPath = -40
;|***                     char   *pszPath;
;|*** 
;|***                     iPpfstool=1;
; Line 396
	*** 0002dc	c7 46 e0 01 00 		mov	WORD PTR [bp-32],1	;iPpfstool
;|*** 
;|***                     if( argv[iArgIndex][2] != '\0' )
; Line 398
	*** 0002e1	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 0002e4	03 db 			add	bx,bx
	*** 0002e6	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 0002e9	8b 18 			mov	bx,WORD PTR [bx][si]
	*** 0002eb	80 7f 02 00 		cmp	BYTE PTR [bx+2],0
	*** 0002ef	74 13 			je	$I676
;|***                     {
;|***                         pszPath = &argv[iArgIndex][2];
; Line 400
	*** 0002f1	8d 47 02 		lea	ax,WORD PTR [bx+2]
	*** 0002f4	89 46 d8 		mov	WORD PTR [bp-40],ax	;pszPath
;|***                         if( *pszPath == ':' )
; Line 401
	*** 0002f7	8b d8 			mov	bx,ax
	*** 0002f9	80 3f 3a 		cmp	BYTE PTR [bx],58	;003aH
	*** 0002fc	75 31 			jne	$I680
;|***                         {
;|***                             pszPath++;
; Line 403
	*** 0002fe	40 			inc	ax
	*** 0002ff	89 46 d8 		mov	WORD PTR [bp-40],ax	;pszPath
;|***                         }
;|***                     }
;|***                     else if( (argc > (i+1) && argv[iArgIndex+1][0] != '-') && 
; Line 406
	*** 000302	eb 2b 			jmp	SHORT $I680
					$I676:
;|***                              (argv[iArgIndex+1][0] != '/') )
; Line 407
	*** 000304	8b 46 e4 		mov	ax,WORD PTR [bp-28]	;i
	*** 000307	40 			inc	ax
	*** 000308	3b 46 04 		cmp	ax,WORD PTR [bp+4]	;argc
	*** 00030b	7d 1d 			jge	$I679
	*** 00030d	8b 76 da 		mov	si,WORD PTR [bp-38]	;iArgIndex
	*** 000310	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;argv
	*** 000313	03 f6 			add	si,si
	*** 000315	8b 58 02 		mov	bx,WORD PTR [bx+2][si]
	*** 000318	80 3f 2d 		cmp	BYTE PTR [bx],45	;002dH
	*** 00031b	74 0d 			je	$I679
	*** 00031d	80 3f 2f 		cmp	BYTE PTR [bx],47	;002fH
	*** 000320	74 08 			je	$I679
;|***                     {
;|***                         pszPath = argv[iArgIndex+1];
; Line 409
	*** 000322	89 5e d8 		mov	WORD PTR [bp-40],bx	;pszPath
;|***                         i++;
; Line 410
	*** 000325	89 46 e4 		mov	WORD PTR [bp-28],ax	;i
;|***                     }
;|***                     else
; Line 412
	*** 000328	eb 05 			jmp	SHORT $I680
					$I679:
;|***                     {
;|***                         pszPath = "*.*";
; Line 414
	*** 00032a	c7 46 d8 00 00 		mov	WORD PTR [bp-40],OFFSET DGROUP:$SG681	;pszPath
;|***                     }
; Line 415
					$I680:
;|***                     DisplayDirectory(pszPath);
; Line 416
	*** 00032f	ff 76 d8 		push	WORD PTR [bp-40]	;pszPath
	*** 000332	e8 00 00 		call	_DisplayDirectory
	*** 000335	eb 79 			jmp	SHORT $L1002
	*** 000337	90 			nop	
;|***                 }
;|***                 break;
;|*** 
;|***             case 'g':
; Line 420
					$SC682:
;|***             case 'r':
;|***             case 'u':
;|***                 {
; Line 423
;	pszSource = -40
;	pszDestination = -42
;|***                     char    *pszSource;
;|***                     char    *pszDestination;
;|*** 
;|***                     iPpfstool=1;
; Line 427
	*** 000338	c7 46 e0 01 00 		mov	WORD PTR [bp-32],1	;iPpfstool
;|***                     if( argv[iArgIndex][2] != '\0' )
; Line 428
	*** 00033d	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 000340	03 db 			add	bx,bx
	*** 000342	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000345	8b 18 			mov	bx,WORD PTR [bx][si]
	*** 000347	80 7f 02 00 		cmp	BYTE PTR [bx+2],0
	*** 00034b	74 13 			je	$I685
;|***                     {
;|***                         pszSource = &argv[iArgIndex][2];
; Line 430
	*** 00034d	8d 47 02 		lea	ax,WORD PTR [bx+2]
	*** 000350	89 46 d8 		mov	WORD PTR [bp-40],ax	;pszPath
;|***                         if( *pszSource == ':' )
; Line 431
	*** 000353	8b d8 			mov	bx,ax
	*** 000355	80 3f 3a 		cmp	BYTE PTR [bx],58	;003aH
	*** 000358	75 2a 			jne	$I687
;|***                         {
;|***                             pszSource++;
; Line 433
	*** 00035a	40 			inc	ax
	*** 00035b	89 46 d8 		mov	WORD PTR [bp-40],ax	;pszPath
;|***                         }
;|***                     }
;|***                     else if( argc > (iArgIndex+1) && argv[iArgIndex+1][0] != '-' && argv[iArgIndex+1][0] != '/' )
; Line 436
	*** 00035e	eb 24 			jmp	SHORT $I687
					$I685:
	*** 000360	8b 46 da 		mov	ax,WORD PTR [bp-38]	;iArgIndex
	*** 000363	40 			inc	ax
	*** 000364	3b 46 04 		cmp	ax,WORD PTR [bp+4]	;argc
	*** 000367	7d 41 			jge	$I688
	*** 000369	8b 76 da 		mov	si,WORD PTR [bp-38]	;iArgIndex
	*** 00036c	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;argv
	*** 00036f	03 f6 			add	si,si
	*** 000371	8b 58 02 		mov	bx,WORD PTR [bx+2][si]
	*** 000374	80 3f 2d 		cmp	BYTE PTR [bx],45	;002dH
	*** 000377	74 31 			je	$I688
	*** 000379	80 3f 2f 		cmp	BYTE PTR [bx],47	;002fH
	*** 00037c	74 2c 			je	$I688
;|***                     {
;|***                         pszSource = argv[iArgIndex+1];
; Line 438
	*** 00037e	89 5e d8 		mov	WORD PTR [bp-40],bx	;pszPath
;|***                         iArgIndex++;
; Line 439
	*** 000381	89 46 da 		mov	WORD PTR [bp-38],ax	;iArgIndex
;|***                     }
;|***                     else
; Line 441
					$I687:
;|***                     {
;|***                         printf("Error source path missing\n");
;|***                         break;
;|***                     }
;|*** 
;|***                     if( argc > (iArgIndex+1) && argv[iArgIndex+1][0] != '-' && argv[iArgIndex+1][0] != '/' )
; Line 447
	*** 000384	8b 46 da 		mov	ax,WORD PTR [bp-38]	;iArgIndex
	*** 000387	40 			inc	ax
	*** 000388	3b 46 04 		cmp	ax,WORD PTR [bp+4]	;argc
	*** 00038b	7d 29 			jge	$I691
	*** 00038d	8b 76 da 		mov	si,WORD PTR [bp-38]	;iArgIndex
	*** 000390	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;argv
	*** 000393	03 f6 			add	si,si
	*** 000395	8b 58 02 		mov	bx,WORD PTR [bx+2][si]
	*** 000398	80 3f 2d 		cmp	BYTE PTR [bx],45	;002dH
	*** 00039b	74 19 			je	$I691
	*** 00039d	80 3f 2f 		cmp	BYTE PTR [bx],47	;002fH
	*** 0003a0	74 14 			je	$I691
;|***                     {
;|***                         pszDestination = argv[iArgIndex+1];
; Line 449
	*** 0003a2	89 5e d6 		mov	WORD PTR [bp-42],bx	;pszDestination
;|***                         i++;
; Line 450
	*** 0003a5	ff 46 e4 		inc	WORD PTR [bp-28]	;i
;|***                     }
;|***                     else
; Line 452
	*** 0003a8	eb 11 			jmp	SHORT $I692
					$I688:
;|***                         printf("Error source path missing\n");
; Line 443
	*** 0003aa	68 00 00 		push	OFFSET DGROUP:$SG690
	*** 0003ad	e8 00 00 		call	_printf
					$L1002:
	*** 0003b0	83 c4 02 		add	sp,2
;|***                         break;
; Line 444
	*** 0003b3	e9 8c 00 		jmp	$SB632
;|***                     }
; Line 445
					$I691:
;|*** 
;|***                     if( argc > (iArgIndex+1) && argv[iArgIndex+1][0] != '-' && argv[iArgIndex+1][0] != '/' )
;|***                     {
;|***                         pszDestination = argv[iArgIndex+1];
;|***                         i++;
;|***                     }
;|***                     else
;|***                     {
;|***                         pszDestination = NULL;
; Line 454
	*** 0003b6	c7 46 d6 00 00 		mov	WORD PTR [bp-42],0	;pszDestination
;|***                     }
; Line 455
					$I692:
;|*** 
;|***                     GetFile( pszSource, pszDestination,
;|***                              cOption == 'r' ? COPY_FLAG_UPDATE_EXISTING :
;|***                              cOption == 'u' ? COPY_FLAG_UPDATE_OR_ADD :
;|***                              0 );
; Line 460
	*** 0003bb	80 7e e6 72 		cmp	BYTE PTR [bp-26],114	;0072H	;cOption
	*** 0003bf	75 05 			jne	$L970
	*** 0003c1	b8 01 00 		mov	ax,1
	*** 0003c4	eb 0e 			jmp	SHORT $L973
					$L970:
	*** 0003c6	80 7e e6 75 		cmp	BYTE PTR [bp-26],117	;0075H	;cOption
	*** 0003ca	75 06 			jne	$L972
	*** 0003cc	b8 02 00 		mov	ax,2
	*** 0003cf	eb 03 			jmp	SHORT $L973
	*** 0003d1	90 			nop	
					$L972:
	*** 0003d2	33 c0 			xor	ax,ax
					$L973:
	*** 0003d4	89 46 d4 		mov	WORD PTR [bp-44],ax
	*** 0003d7	50 			push	ax
	*** 0003d8	ff 76 d6 		push	WORD PTR [bp-42]	;pszDestination
	*** 0003db	ff 76 d8 		push	WORD PTR [bp-40]	;pszPath
	*** 0003de	e8 00 00 		call	_GetFile
	*** 0003e1	83 c4 06 		add	sp,6
;|***                 }
;|***                 break;
; Line 462
	*** 0003e4	eb 5c 			jmp	SHORT $SB632
;|*** 
;|***             default:
; Line 464
					$L975:
	*** 0003e6	2c 64 			sub	al,100	;0064H
	*** 0003e8	75 03 			jne	$JCC1000
	*** 0003ea	e9 d1 fd 		jmp	$SC650
					$JCC1000:
	*** 0003ed	fe c8 			dec	al
	*** 0003ef	75 03 			jne	$JCC1007
	*** 0003f1	e9 06 fe 		jmp	$SC654
					$JCC1007:
	*** 0003f4	2c 02 			sub	al,2
	*** 0003f6	75 03 			jne	$JCC1014
	*** 0003f8	e9 3d ff 		jmp	$SC682
					$JCC1014:
					$SD693:
;|*** 
;|***                 printf("Unrecognized option - %s\n", argv[iArgIndex]);
; Line 466
	*** 0003fb	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 0003fe	03 db 			add	bx,bx
	*** 000400	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000403	ff 30 			push	WORD PTR [bx][si]
	*** 000405	68 00 00 		push	OFFSET DGROUP:$SG694
	*** 000408	e8 00 00 		call	_printf
	*** 00040b	83 c4 04 		add	sp,4
;|*** 
;|***                 // Fall through to display usage 
;|*** 
;|***             case '?':
; Line 470
					$SC695:
;|***             case 'h':
;|*** 
;|***                 // Display usage data
;|*** 
;|***                 usage( argv[0] );
; Line 475
	*** 00040e	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;argv
	*** 000411	ff 37 			push	WORD PTR [bx]
	*** 000413	e8 00 00 		call	usage
	*** 000416	83 c4 02 		add	sp,2
	*** 000419	e9 06 fd 		jmp	$L997
					$L974:
	*** 00041c	2c 6b 			sub	al,107	;006bH
	*** 00041e	3d 0a 00 		cmp	ax,10	;000aH
	*** 000421	77 d8 			ja	$SD693
	*** 000423	03 c0 			add	ax,ax
	*** 000425	93 			xchg	ax,bx
	*** 000426	2e ff a7 00 00 		jmp	WORD PTR cs:$L976[bx]
	*** 00042b	90 			nop	
					$L976:
	*** 00042c	00 00 				DW	$SC659
	*** 00042e	00 00 				DW	$SC664
	*** 000430	00 00 				DW	$SD693
	*** 000432	00 00 				DW	$SC667
	*** 000434	00 00 				DW	$SD693
	*** 000436	00 00 				DW	$SC670
	*** 000438	00 00 				DW	$SC672
	*** 00043a	00 00 				DW	$SC682
	*** 00043c	00 00 				DW	$SC674
	*** 00043e	00 00 				DW	$SD693
	*** 000440	00 00 				DW	$SC682
					$SB632:
;|***                 ret = 1;
;|***                 goto main_error;
;|***             }
;|***         }
; Line 479
	*** 000442	ff 46 da 		inc	WORD PTR [bp-38]	;iArgIndex
					$F627:
	*** 000445	8b 46 04 		mov	ax,WORD PTR [bp+4]	;argc
	*** 000448	39 46 da 		cmp	WORD PTR [bp-38],ax	;iArgIndex
	*** 00044b	7d 1a 			jge	$FB629
;|***             if( argv[iArgIndex][0] != '/' && argv[iArgIndex][0] != '-' )
; Line 222
	*** 00044d	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 000450	03 db 			add	bx,bx
	*** 000452	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000455	8b 18 			mov	bx,WORD PTR [bx][si]
	*** 000457	80 3f 2f 		cmp	BYTE PTR [bx],47	;002fH
	*** 00045a	75 03 			jne	$JCC1114
	*** 00045c	e9 47 fc 		jmp	$I630
					$JCC1114:
	*** 00045f	80 3f 2d 		cmp	BYTE PTR [bx],45	;002dH
	*** 000462	75 03 			jne	$JCC1122
	*** 000464	e9 3f fc 		jmp	$I630
					$JCC1122:
;|***             {
;|***                 break;
; Line 224
					$FB629:
;|***             }
;|*** 
;|***             cOption = (char)tolower(argv[iArgIndex][1]);
;|*** 
;|***             // Process according to option character
;|*** 
;|***             switch( cOption )
;|***             {
;|***             case 'b':   /* Baud rate */
;|*** 
;|***                 if( argv[iArgIndex][2] != ':' ||
;|***                     argv[iArgIndex][3] < '0' || argv[iArgIndex][3] > '9' )
;|***                 {
;|***                     printf("Invalid option - %s\n", argv[iArgIndex]);
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|*** 
;|***                 ulBaudRate = atol(&argv[iArgIndex][3]);
;|*** 
;|***                 for( i=0; i < NUM_BAUD_RATES; i++ )
;|***                 {
;|***                     if( BaudTable[i].ulRate == ulBaudRate )
;|***                     {
;|***                         BootArgs.ucBaudDivisor = BaudTable[i].ucDivisor;
;|***                         break;
;|***                     }
;|***                 }
;|*** 
;|***                 if( i >= NUM_BAUD_RATES )
;|***                 {
;|***                     printf( "Unsupported baud rate - %s\n", argv[iArgIndex] );
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 break;
;|*** 
;|***             case 'c':
;|*** 
;|***                 // COM Port Parameter
;|***                 //
;|***                 // Allowable values for the COM ports 1-4. Zero (0) is 
;|***                 // allowed as a way to disable use of the COM port and is
;|***                 // allowed by ...\csp\i486\oal\debug.c.
;|*** 
;|***                 if( (argv[iArgIndex][2] == ':') &&
;|***                     (argv[iArgIndex][3] >= '0') &&  
;|***                     (argv[iArgIndex][3] <= '4') )
;|***                 {
;|***                     BootArgs.ucComPort = (UCHAR)(argv[iArgIndex][3] - '0');
;|***                 }
;|***                 else
;|***                 {
;|***                     printf( "Invalid option - %s\n", argv[iArgIndex] );
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 break;
;|*** 
;|***             case 'd':   /* Display mode */
;|*** 
;|***                 if( argv[iArgIndex][2] != ':' ||
;|***                     argv[iArgIndex][3] < '0' || argv[iArgIndex][3] > '6' )
;|***                 {
;|***                     printf( "Invalid option - %s\n", argv[iArgIndex] );
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 iDesiredMode = (int)(argv[iArgIndex][3] - '0');
;|***                 break;
;|*** 
;|***             case 'e':
;|***                 if( bRNDISDownload )
;|***                 {
;|***                     printf( "The /E and /K options are mutually exclusive"
;|***                             " - please choose one of them.\r\n" );
;|*** 
;|***                     goto main_error;
;|***                 }
;|***                 if( !ParseEthernetOptions(argv[iArgIndex]) )
;|***                 {
;|***                     printf("Invalid option - %s\n", argv[iArgIndex]);
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 bEtherDownload = TRUE;
;|***                 break;
;|*** 
;|***             case 'k':   /* RNDIS flags */
;|*** 
;|***                 if( bEtherDownload )
;|***                 {
;|***                     printf( "The /E and /K options are mutually exclusive"
;|***                             "- please choose one of them.\r\n");
;|***                     goto main_error;
;|***                 }
;|***                 if( !ParseEthernetOptions(argv[iArgIndex]) )
;|***                 {
;|***                     printf("Invalid option - %s\n", argv[iArgIndex]);
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 bRNDISDownload = TRUE;
;|***                 break;
;|*** 
;|***             case 'l':   
;|*** 
;|***                 // VESA VBE Linear/Flat Framebuffer display mode 
;|*** 
;|***                 if( !ParseVESAOptions( argv[iArgIndex] ) )
;|***                 {
;|***                     printf( "Invalid option - %s\n", argv[iArgIndex] );
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 iDesiredMode = BootArgs.vesaMode;
;|*** #if 0
;|*** 
;|***                 // Video Mode Debug - display and hang
;|*** 
;|***                 printf( "VESA Boot Options\n" );
;|***                 printf( "vesaMode........: 0x%x\n", BootArgs.vesaMode );
;|***                 printf( "xDisplayScreen..: %d\n", BootArgs.cxDisplayScreen );
;|***                 printf( "YDisplayScreen..: %d\n", BootArgs.cyDisplayScreen );
;|***                 printf( "bppScreen.......: %d\n", BootArgs.bppScreen );
;|***                 printf( "xPhysScreen.....: %d\n", BootArgs.cxPhysicalScreen );  
;|***                 printf( "yPhysScreen.....: %d\n", BootArgs.cyPhysicalScreen );  
;|*** 
;|***                 while( 1 )
;|***                 {
;|***                     ;
;|***                 }
;|*** #endif
;|***                 break;
;|*** 
;|***             case 'n':   /* Device name specified */
;|*** 
;|***                 if( !ParseDeviceName(argv[iArgIndex]) )
;|***                 {
;|***                     printf("Invalid option - %s\n", argv[iArgIndex]); 
;|***                     ret = 1;
;|***                     goto main_error;
;|***                 }
;|***                 break;
;|*** 
;|***             case 'p':   /* Parallel port boot download */
;|*** 
;|***                 bParallelDownload=TRUE;
;|***                 pszFileName= NULL;
;|***                 break;
;|*** 
;|***             case 'a':   /* Use permanent storage to store image */
;|*** 
;|***                 bBackupImage=TRUE;
;|***                 break;
;|*** 
;|***             case 'q':   /* Serial port boot download */
;|*** 
;|***                 bSerialDownload=TRUE;
;|***                 pszFileName= NULL;
;|***                 break;
;|*** 
;|***             case 'v':
;|*** 
;|***                 bVerbose = TRUE;
;|***                 break;
;|*** 
;|***             case 's':
;|***                 {
;|***                     char   *pszPath;
;|*** 
;|***                     iPpfstool=1;
;|*** 
;|***                     if( argv[iArgIndex][2] != '\0' )
;|***                     {
;|***                         pszPath = &argv[iArgIndex][2];
;|***                         if( *pszPath == ':' )
;|***                         {
;|***                             pszPath++;
;|***                         }
;|***                     }
;|***                     else if( (argc > (i+1) && argv[iArgIndex+1][0] != '-') && 
;|***                              (argv[iArgIndex+1][0] != '/') )
;|***                     {
;|***                         pszPath = argv[iArgIndex+1];
;|***                         i++;
;|***                     }
;|***                     else
;|***                     {
;|***                         pszPath = "*.*";
;|***                     }
;|***                     DisplayDirectory(pszPath);
;|***                 }
;|***                 break;
;|*** 
;|***             case 'g':
;|***             case 'r':
;|***             case 'u':
;|***                 {
;|***                     char    *pszSource;
;|***                     char    *pszDestination;
;|*** 
;|***                     iPpfstool=1;
;|***                     if( argv[iArgIndex][2] != '\0' )
;|***                     {
;|***                         pszSource = &argv[iArgIndex][2];
;|***                         if( *pszSource == ':' )
;|***                         {
;|***                             pszSource++;
;|***                         }
;|***                     }
;|***                     else if( argc > (iArgIndex+1) && argv[iArgIndex+1][0] != '-' && argv[iArgIndex+1][0] != '/' )
;|***                     {
;|***                         pszSource = argv[iArgIndex+1];
;|***                         iArgIndex++;
;|***                     }
;|***                     else
;|***                     {
;|***                         printf("Error source path missing\n");
;|***                         break;
;|***                     }
;|*** 
;|***                     if( argc > (iArgIndex+1) && argv[iArgIndex+1][0] != '-' && argv[iArgIndex+1][0] != '/' )
;|***                     {
;|***                         pszDestination = argv[iArgIndex+1];
;|***                         i++;
;|***                     }
;|***                     else
;|***                     {
;|***                         pszDestination = NULL;
;|***                     }
;|*** 
;|***                     GetFile( pszSource, pszDestination,
;|***                              cOption == 'r' ? COPY_FLAG_UPDATE_EXISTING :
;|***                              cOption == 'u' ? COPY_FLAG_UPDATE_OR_ADD :
;|***                              0 );
;|***                 }
;|***                 break;
;|*** 
;|***             default:
;|*** 
;|***                 printf("Unrecognized option - %s\n", argv[iArgIndex]);
;|*** 
;|***                 // Fall through to display usage 
;|*** 
;|***             case '?':
;|***             case 'h':
;|*** 
;|***                 // Display usage data
;|*** 
;|***                 usage( argv[0] );
;|***                 ret = 1;
;|***                 goto main_error;
;|***             }
;|***         }
;|*** 
;|***         if( iArgIndex == (argc - 1) )
; Line 481
	*** 000467	2b 46 da 		sub	ax,WORD PTR [bp-38]	;iArgIndex
	*** 00046a	48 			dec	ax
	*** 00046b	75 0d 			jne	$I696
;|***         {
;|***             pszFileName = argv[iArgIndex];
; Line 483
	*** 00046d	8b 5e da 		mov	bx,WORD PTR [bp-38]	;iArgIndex
	*** 000470	03 db 			add	bx,bx
	*** 000472	8b 76 06 		mov	si,WORD PTR [bp+6]	;argv
	*** 000475	8b 00 			mov	ax,WORD PTR [bx][si]
	*** 000477	89 46 fe 		mov	WORD PTR [bp-2],ax	;pszFileName
;|***         }
;|***     }
; Line 485
					$I696:
;|*** 
;|***     if( iPpfstool )
; Line 487
	*** 00047a	83 7e e0 00 		cmp	WORD PTR [bp-32],0	;iPpfstool
	*** 00047e	74 08 			je	$I697
;|***     {
;|***         ret = 0;
; Line 489
	*** 000480	c7 46 e2 00 00 		mov	WORD PTR [bp-30],0	;ret
;|***         goto main_error;
; Line 490
	*** 000485	e9 60 01 		jmp	$main_error639
;|***     }
;|*** 
;|***     if( !XmsIsInstalled() )
; Line 493
					$I697:
	*** 000488	e8 00 00 		call	_XmsIsInstalled
	*** 00048b	0b c0 			or	ax,ax
	*** 00048d	75 11 			jne	$I698
;|***     {
;|***         printf( "HIMEM.SYS must be loaded\n" );
; Line 495
	*** 00048f	68 00 00 		push	OFFSET DGROUP:$SG699
	*** 000492	e8 00 00 		call	_printf
	*** 000495	83 c4 02 		add	sp,2
;|***         ret = 2;
; Line 496
	*** 000498	c7 46 e2 02 00 		mov	WORD PTR [bp-30],2	;ret
;|***         goto main_error;
; Line 497
	*** 00049d	e9 48 01 		jmp	$main_error639
;|***     }
;|*** 
;|***     if( bVerbose )
; Line 500
					$I698:
	*** 0004a0	83 7e f0 00 		cmp	WORD PTR [bp-16],0	;bVerbose
	*** 0004a4	74 39 			je	$I703
;|***     {
;|***         if( (xmsError = XmsQueryA20(&bEnabled)) != XMS_SUCCESS )
; Line 502
	*** 0004a6	8d 46 f2 		lea	ax,WORD PTR [bp-14]	;bEnabled
	*** 0004a9	50 			push	ax
	*** 0004aa	e8 00 00 		call	_XmsQueryA20
	*** 0004ad	83 c4 02 		add	sp,2
	*** 0004b0	89 46 f4 		mov	WORD PTR [bp-12],ax	;xmsError
	*** 0004b3	0b c0 			or	ax,ax
	*** 0004b5	74 19 			je	$I701
;|***         {
;|***             printf( "Error querying A20 status - %s\n", 
;|***                 XmsErrorString(xmsError) );
; Line 505
	*** 0004b7	50 			push	ax
	*** 0004b8	e8 00 00 		call	_XmsErrorString
	*** 0004bb	83 c4 02 		add	sp,2
	*** 0004be	50 			push	ax
	*** 0004bf	68 00 00 		push	OFFSET DGROUP:$SG702
	*** 0004c2	e8 00 00 		call	_printf
	*** 0004c5	83 c4 04 		add	sp,4
;|***             ret = 3;
; Line 506
	*** 0004c8	c7 46 e2 03 00 		mov	WORD PTR [bp-30],3	;ret
;|***             goto main_error;
; Line 507
	*** 0004cd	e9 18 01 		jmp	$main_error639
;|***         }
;|*** 
;|***         if( bEnabled )
; Line 510
					$I701:
	*** 0004d0	83 7e f2 00 		cmp	WORD PTR [bp-14],0	;bEnabled
	*** 0004d4	74 09 			je	$I703
;|***         {
;|***             printf( "Warning A20 line already enabled\n" );
; Line 512
	*** 0004d6	68 00 00 		push	OFFSET DGROUP:$SG704
	*** 0004d9	e8 00 00 		call	_printf
	*** 0004dc	83 c4 02 		add	sp,2
;|***         }
;|***     }
; Line 514
					$I703:
;|*** 
;|***     // Check if PCI Bios is available, if so find out config mechanism
;|*** 
;|***     BootArgs.ucPCIConfigType = GetPCIConfigMechanism();
; Line 518
	*** 0004df	e8 00 00 		call	GetPCIConfigMechanism
	*** 0004e2	a2 03 00 		mov	BYTE PTR _BootArgs+3,al
;|*** 
;|***     // Load the boot image
;|*** 
;|***     if( !LoadImage( bVerbose, bParallelDownload, pszFileName, &ulEntryPoint) )
; Line 522
	*** 0004e5	8d 46 fa 		lea	ax,WORD PTR [bp-6]	;ulEntryPoint
	*** 0004e8	50 			push	ax
	*** 0004e9	ff 76 fe 		push	WORD PTR [bp-2]	;pszFileName
	*** 0004ec	ff 76 ee 		push	WORD PTR [bp-18]	;bParallelDownload
	*** 0004ef	ff 76 f0 		push	WORD PTR [bp-16]	;bVerbose
	*** 0004f2	e8 00 00 		call	LoadImage
	*** 0004f5	83 c4 08 		add	sp,8
	*** 0004f8	0b c0 			or	ax,ax
	*** 0004fa	75 08 			jne	$I705
;|***     {
;|***         ret = 4;
; Line 524
	*** 0004fc	c7 46 e2 04 00 		mov	WORD PTR [bp-30],4	;ret
;|***         goto main_error;
; Line 525
	*** 000501	e9 e4 00 		jmp	$main_error639
;|***     }
;|*** 
;|***     // Enable A20 line
;|*** 
;|***     if( (xmsError = XmsLocalEnableA20()) != XMS_SUCCESS )
; Line 530
					$I705:
	*** 000504	e8 00 00 		call	_XmsLocalEnableA20
	*** 000507	89 46 f4 		mov	WORD PTR [bp-12],ax	;xmsError
	*** 00050a	0b c0 			or	ax,ax
	*** 00050c	74 12 			je	$I706
;|***     {
;|***         printf("Can't enable A20 line, error = 0x%4.4X\n", xmsError);
; Line 532
	*** 00050e	50 			push	ax
	*** 00050f	68 00 00 		push	OFFSET DGROUP:$SG707
	*** 000512	e8 00 00 		call	_printf
	*** 000515	83 c4 04 		add	sp,4
;|*** 
;|***         ret = 5;
; Line 534
	*** 000518	c7 46 e2 05 00 		mov	WORD PTR [bp-30],5	;ret
;|***         goto main_error;
; Line 535
	*** 00051d	e9 c8 00 		jmp	$main_error639
;|***     }
;|*** 
;|***     // Set the video mode
;|*** 
;|***     BootArgs.ucVideoMode = SetVideoMode( iDesiredMode );
; Line 540
					$I706:
	*** 000520	ff 36 00 00 		push	WORD PTR _iDesiredMode
	*** 000524	e8 00 00 		call	_SetVideoMode
	*** 000527	83 c4 02 		add	sp,2
	*** 00052a	a2 00 00 		mov	BYTE PTR _BootArgs,al
;|*** 
;|***     if( BootArgs.ucVideoMode == 0 )
; Line 542
	*** 00052d	0a c0 			or	al,al
	*** 00052f	75 29 			jne	$I708
;|***     {
;|***         // if using default mode set params for flat framebuffer driver.
;|*** 
;|***         BootArgs.cxDisplayScreen     = 320; 
;|***         BootArgs.cyDisplayScreen     = 200;
;|***         BootArgs.cxPhysicalScreen    = 320; 
;|***         BootArgs.cyPhysicalScreen    = 200;
; Line 549
	*** 000531	b8 c8 00 		mov	ax,200	;00c8H
	*** 000534	a3 70 00 		mov	WORD PTR _BootArgs+112,ax
	*** 000537	a3 74 00 		mov	WORD PTR _BootArgs+116,ax
;|***         BootArgs.bppScreen           = 8;
; Line 550
	*** 00053a	c7 06 78 00 08 00 	mov	WORD PTR _BootArgs+120,8
;|***         BootArgs.cbScanLineLength    = 320;
; Line 551
	*** 000540	b8 40 01 		mov	ax,320	;0140H
	*** 000543	a3 6e 00 		mov	WORD PTR _BootArgs+110,ax
	*** 000546	a3 72 00 		mov	WORD PTR _BootArgs+114,ax
	*** 000549	a3 76 00 		mov	WORD PTR _BootArgs+118,ax
;|***         BootArgs.pvFlatFrameBuffer   = 0x800A0000;
; Line 552
	*** 00054c	c7 06 68 00 00 00 	mov	WORD PTR _BootArgs+104,0
	*** 000552	c7 06 6a 00 0a 80 	mov	WORD PTR _BootArgs+106,-32758	;800aH
;|***     }
;|***     else if( BootArgs.ucVideoMode != 0xFF )
; Line 554
	*** 000558	eb 21 			jmp	SHORT $I710
					$I708:
	*** 00055a	80 3e 00 00 ff 		cmp	BYTE PTR _BootArgs,255	;00ffH
	*** 00055f	74 1a 			je	$I710
;|***     {
;|***         // if not using VESA mode clear these so flat 
;|***         // framebuffer driver sees all zeroes and faults.
;|*** 
;|***         BootArgs.cxDisplayScreen     = 0;   
;|***         BootArgs.cyDisplayScreen     = 0;
;|***         BootArgs.cxPhysicalScreen    = 0;   
;|***         BootArgs.cyPhysicalScreen    = 0;
;|***         BootArgs.bppScreen           = 0;
;|***         BootArgs.cbScanLineLength    = 0;
; Line 564
	*** 000561	33 c0 			xor	ax,ax
	*** 000563	a3 6e 00 		mov	WORD PTR _BootArgs+110,ax
	*** 000566	a3 70 00 		mov	WORD PTR _BootArgs+112,ax
	*** 000569	a3 72 00 		mov	WORD PTR _BootArgs+114,ax
	*** 00056c	a3 74 00 		mov	WORD PTR _BootArgs+116,ax
	*** 00056f	a3 78 00 		mov	WORD PTR _BootArgs+120,ax
	*** 000572	a3 76 00 		mov	WORD PTR _BootArgs+118,ax
;|***         BootArgs.pvFlatFrameBuffer   = 0;
; Line 565
	*** 000575	a3 6a 00 		mov	WORD PTR _BootArgs+106,ax
	*** 000578	a3 68 00 		mov	WORD PTR _BootArgs+104,ax
;|***     }
;|*** 
;|***     if( bSerialDownload )
; Line 568
					$I710:
	*** 00057b	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 000580	74 05 			je	$I711
;|***     {
;|***         BootArgs.ucBaudDivisor|=0x80;
; Line 570
	*** 000582	80 0e 02 00 80 		or	BYTE PTR _BootArgs+2,128	;0080H
;|***     }
;|*** 
;|***     if( bParallelDownload )
; Line 573
					$I711:
	*** 000587	83 7e ee 00 		cmp	WORD PTR [bp-18],0	;bParallelDownload
	*** 00058b	74 06 			je	$I712
;|***     {
;|***         BootArgs.KitlTransport = GetJumpFlags();
; Line 575
	*** 00058d	e8 00 00 		call	GetJumpFlags
	*** 000590	a3 5a 00 		mov	WORD PTR _BootArgs+90,ax
;|***     }
;|*** 
;|***     if( bBackupImage )
; Line 578
					$I712:
	*** 000593	83 7e ec 00 		cmp	WORD PTR [bp-20],0	;bBackupImage
	*** 000597	74 05 			je	$I713
;|***     {
;|***         BootArgs.ucLoaderFlags |= LDRFL_FLASH_BACKUP;
; Line 580
	*** 000599	80 0e 0c 00 80 		or	BYTE PTR _BootArgs+12,128	;0080H
;|***     }
;|*** 
;|***     if( bVerbose )
; Line 583
					$I713:
	*** 00059e	83 7e f0 00 		cmp	WORD PTR [bp-16],0	;bVerbose
	*** 0005a2	74 0f 			je	$I714
;|***     {
;|***         printf( "Jumping to 0x%8.8lX\n", ulEntryPoint );
; Line 585
	*** 0005a4	ff 76 fc 		push	WORD PTR [bp-4]
	*** 0005a7	ff 76 fa 		push	WORD PTR [bp-6]	;ulEntryPoint
	*** 0005aa	68 00 00 		push	OFFSET DGROUP:$SG715
	*** 0005ad	e8 00 00 		call	_printf
	*** 0005b0	83 c4 06 		add	sp,6
;|***     }
;|*** 
;|***     // Convert arguments to linear addres
;|*** 
;|***     ulArguments = (((ULONG)(void far *)&BootArgs) >> 16) << 4;
; Line 590
					$I714:
;|***     ulArguments += ((ULONG)(void far *)&BootArgs) & 0xFFFF;
;|*** 
;|***     // Execute the image
;|*** 
;|***     Launch( ulEntryPoint, ulArguments );
; Line 595
	*** 0005b3	8c d8 			mov	ax,ds
	*** 0005b5	2b d2 			sub	dx,dx
	*** 0005b7	03 c0 			add	ax,ax
	*** 0005b9	13 d2 			adc	dx,dx
	*** 0005bb	03 c0 			add	ax,ax
	*** 0005bd	13 d2 			adc	dx,dx
	*** 0005bf	03 c0 			add	ax,ax
	*** 0005c1	13 d2 			adc	dx,dx
	*** 0005c3	03 c0 			add	ax,ax
	*** 0005c5	13 d2 			adc	dx,dx
	*** 0005c7	05 00 00 		add	ax,OFFSET DGROUP:_BootArgs
	*** 0005ca	83 d2 00 		adc	dx,0
	*** 0005cd	89 46 f6 		mov	WORD PTR [bp-10],ax	;ulArguments
	*** 0005d0	89 56 f8 		mov	WORD PTR [bp-8],dx
	*** 0005d3	52 			push	dx
	*** 0005d4	50 			push	ax
	*** 0005d5	ff 76 fc 		push	WORD PTR [bp-4]
	*** 0005d8	ff 76 fa 		push	WORD PTR [bp-6]	;ulEntryPoint
	*** 0005db	e8 00 00 		call	_Launch
	*** 0005de	83 c4 08 		add	sp,8
;|*** 
;|***     // Launch should not return
;|*** 
;|***     return( 0 );
; Line 599
	*** 0005e1	33 c0 			xor	ax,ax
	*** 0005e3	5e 			pop	si
	*** 0005e4	5f 			pop	di
	*** 0005e5	c9 			leave	
	*** 0005e6	c3 			ret	
	*** 0005e7	90 			nop	
;|*** 
;|*** 
;|***     // Main Error Handler
;|*** 
;|*** main_error:
; Line 604
					$main_error639:
;|*** 
;|***     // Make sure we unlock and free extended memory
;|*** 
;|***     if( usBlockHandle )
; Line 608
	*** 0005e8	83 3e 00 00 00 		cmp	WORD PTR _usBlockHandle,0
	*** 0005ed	74 14 			je	$I716
;|***     {
;|***         XmsUnlockExtendedMemory(usBlockHandle);
; Line 610
	*** 0005ef	ff 36 00 00 		push	WORD PTR _usBlockHandle
	*** 0005f3	e8 00 00 		call	_XmsUnlockExtendedMemory
	*** 0005f6	83 c4 02 		add	sp,2
;|***         XmsFreeExtendedMemory(usBlockHandle);
; Line 611
	*** 0005f9	ff 36 00 00 		push	WORD PTR _usBlockHandle
	*** 0005fd	e8 00 00 		call	_XmsFreeExtendedMemory
	*** 000600	83 c4 02 		add	sp,2
;|***     }
;|*** 
;|***     //printf("\n\n               Press any key to cancel.\n");
;|*** 	printf("\n\n             ==============Press any key to cancel==============\n ");
; Line 615
					$I716:
	*** 000603	68 00 00 		push	OFFSET DGROUP:$SG717
	*** 000606	e8 00 00 		call	_printf
	*** 000609	83 c4 02 		add	sp,2
;|*** 	__asm
;|***     {
;|***         push    dx
; Line 618
	*** 00060c	52 			push	dx
;|***         xor     ax,ax
; Line 619
	*** 00060d	33 c0 			xor	ax,ax
;|***         int     0x16
; Line 620
	*** 00060f	cd 16 			int	22	;0016H
;|***         pop     dx
; Line 621
	*** 000611	5a 			pop	dx
;|***     }
; Line 622
;|***     // Indicate status
;|*** 
;|***     return( ret );
; Line 625
	*** 000612	8b 46 e2 		mov	ax,WORD PTR [bp-30]	;ret
;|*** }
; Line 626
	*** 000615	5e 			pop	si
	*** 000616	5f 			pop	di
	*** 000617	c9 			leave	
	*** 000618	c3 			ret	
	*** 000619	90 			nop	

_main	ENDP

usage	PROC NEAR
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Function Name:  usage( char *pszProgramNameArg )
;|*** //  Description..:  This function displays program usage information.
;|*** //  Inputs.......:  char *      ProgramName
;|*** //  Outputs......:  none
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** static void usage( char *pszProgramNameArg ) 
;|*** {
; Line 638
	*** 00061a	c8 02 00 00 		enter	2,0
;	pszProgram = -2
;	pszProgramNameArg = 4
;|***     char *pszProgram;
;|*** 
;|***     pszProgram = strrchr(pszProgramNameArg, '\\');
;|*** 
;|***     if( pszProgram != NULL )
; Line 643
	*** 00061e	6a 5c 			push	92	;005cH
	*** 000620	ff 76 04 		push	WORD PTR [bp+4]	;pszProgramNameArg
	*** 000623	e8 00 00 		call	_strrchr
	*** 000626	83 c4 04 		add	sp,4
	*** 000629	89 46 fe 		mov	WORD PTR [bp-2],ax	;pszProgram
	*** 00062c	0b c0 			or	ax,ax
	*** 00062e	74 04 			je	$I722
;|***     {
;|***         pszProgram++;
; Line 645
	*** 000630	40 			inc	ax
	*** 000631	eb 04 			jmp	SHORT $L1003
	*** 000633	90 			nop	
					$I722:
;|***     }
;|***     else
;|***     {
;|***         pszProgram = pszProgramNameArg;
; Line 649
	*** 000634	8b 46 04 		mov	ax,WORD PTR [bp+4]	;pszProgramNameArg
					$L1003:
	*** 000637	89 46 fe 		mov	WORD PTR [bp-2],ax	;pszProgram
;|***     }
;|*** 
;|***     printf(
;|***           "\n"
;|***           "%s: Loads a BIN image into memory and boots it.\n"
;|***           "\n"
;|***           "Usage:%s /B:baud /C:Port /D:display /P /H /V /N:name\n"
;|***           "  (/E|/K):IO:IRQ[:<dotted IP>] /L:VXxVYxBPP[:PXxPY] <file name>\n"
;|***           "\n"
;|***           "  /B  Baud Rate [9600|19200|38400(default)|57600|115200]"
;|***           "\n"
;|***           "  /C  Communications Port [0=disable|1|2|3|4]"
;|***           "\n"
;|***           "  /D  Display Resolution (for VESA modes, use the /L option instead).\n"
;|***           "      0 = 320x200x256 (default), 1 = 480x240x256,\n"
;|***           "      2 = 640x480x256, 3 = 800x600x256, 4 = 1024x768x256\n"
;|***           "      5 = 240x320x256, 6 = 208x240x256\n"
;|***           "\n"
;|***           "  /P  Parallel port boot download.\n"
;|***           "\n"
;|***           "  /A  Use permanent storage device to store NK image.\n"
;|***           "\n"
;|***           "  /H  Help - displays this message.\n"
;|***           "\n"
;|***           "  Default <file name> is NK.BIN except for /P option which uses\n"
;|***           "  default on host unless <file name> specified.\n"
;|***           "\n"
;|***           "Press any key for more options...",
;|*** 
;|***           pszProgram, pszProgram );
; Line 679
	*** 00063a	50 			push	ax
	*** 00063b	50 			push	ax
	*** 00063c	68 00 00 		push	OFFSET DGROUP:$SG724
	*** 00063f	e8 00 00 		call	_printf
	*** 000642	83 c4 06 		add	sp,6
;|*** 
;|***     __asm
;|***     {
;|***         push    dx
; Line 683
	*** 000645	52 			push	dx
;|***         xor     ax,ax
; Line 684
	*** 000646	33 c0 			xor	ax,ax
;|***         int     0x16
; Line 685
	*** 000648	cd 16 			int	22	;0016H
;|***         pop     dx
; Line 686
	*** 00064a	5a 			pop	dx
;|***     }
; Line 687
;|*** 
;|***     printf(
;|***           "\n"
;|***           "\n"
;|***           "\n"
;|***           "Usage:%s /B:baud /C:Port /D:display /P /H /V /N:name\n"
;|***           "  (/E|/K):IO:IRQ[:<dotted IP>] /L:VXxVYxBPP[:PXxPY] <file name>\n"
;|***           "\n"
;|***           "  /V  Verbose - displays extra status information during boot.\n"
;|***           "\n"
;|***           "  /E:IO:IRQ[:<dotted IP>]  (Debug Ethernet Card parameters)\n"
;|***           "      IO - IO Base Address (specified in hexadecimal)\n"
;|***           "      IRQ - Interrupt (specified in decimal or hexadecimal)\n"
;|***           "      Dotted IP - (optional) static IP address (No DHCP)\n"
;|***           "    NOTE: The /E and /K options are mutually exclusive.\n"
;|***           "\n"
;|***           "  /K:IO:IRQ[:<dotted IP>]  (RNDIS Card parameters)\n"
;|***           "      IO - IO Base Address (specified in hexadecimal)\n"
;|***           "      IRQ - Interrupt (specified in decimal or hexadecimal)\n"
;|***           "      Dotted IP - (optional) static IP address (No DHCP)\n"
;|***           "    NOTE: The /E and /K options are mutually exclusive.\n"
;|***           "\n"
;|***           "  /L:DXxDYxBPP[:PXxPY] (Use VESA VBE Linear/Flat Framebuffer video mode)\n"
;|***           "      DX, DY  - Display X and Y Sizes\n"
;|***           "      BPP - Bits Per Pixel Color Depth (8, 16, 24, or 32)\n"
;|***           "      PX, PY  - (optional) Physical Screen X and Y Sizes to simulate a\n"
;|***           "                small device display (PX & PY should be greater than DX & DY)."
;|***           "\n"
;|***           " /N:name  Optionally specify a device name to be used when creating\n"
;|***           "          the Ethernet debug name (for host-side connectivity).\n"
;|***           "\n"
;|***           "Press any key for more options...",
;|*** 
;|***           pszProgram );
; Line 721
	*** 00064b	ff 76 fe 		push	WORD PTR [bp-2]	;pszProgram
	*** 00064e	68 00 00 		push	OFFSET DGROUP:$SG725
	*** 000651	e8 00 00 		call	_printf
	*** 000654	83 c4 04 		add	sp,4
;|*** 
;|***     __asm
;|***     {
;|***         push    dx
; Line 725
	*** 000657	52 			push	dx
;|***         xor     ax,ax
; Line 726
	*** 000658	33 c0 			xor	ax,ax
;|***         int     0x16
; Line 727
	*** 00065a	cd 16 			int	22	;0016H
;|***         pop     dx
; Line 728
	*** 00065c	5a 			pop	dx
;|***     }
; Line 729
;|*** 
;|***     printf(
;|***           "\n"
;|***           "Usage: %s -s[:]<pattern> -(g|r|u)[[:]<pattern> [<destination>]\n"
;|***           "-s    Show a directory of files matching <pattern>.\n"
;|***           "\n"
;|***           "-g    Get files matching <pattern> and copy them to the\n"
;|***           "      optionally specified <destination>.  Any existing file with\n"
;|***           "      the same name will be overwritten.\n"
;|***           "\n"
;|***           "-r    Refresh files matching <pattern> which already exist in <destination>\n"
;|***           "      and have a timestamp newer than the one in <destination>.\n"
;|***           "\n"
;|***           "-u    Update files matching <pattern> which don't already exist in\n"
;|***           "      <destination> or those that have a timestamp newer than those\n"
;|***           "      in <destination>.\n"
;|***           "\n"
;|***           "<pattern> Windows filename path with optional wildcard characters.\n"
;|***           "\n"
;|***           "<destination> If not specified then the current directory is the default.\n"
;|***           "      If specified and it doesn't exist and the last character is \\,\n"
;|***           "      then the directory is created.  Otherwise <destination> is\n"
;|***           "      treated as the name of the file.\n"
;|***           "      It is an error for <pattern> to match multiple files\n"
;|***           "      when <destination> specifies a file.\n"
;|*** 		  "For CE Collections - Last built with ver.2.01-Beta1-03",
;|*** 
;|***           pszProgram );
; Line 757
	*** 00065d	ff 76 fe 		push	WORD PTR [bp-2]	;pszProgram
	*** 000660	68 00 00 		push	OFFSET DGROUP:$SG726
	*** 000663	e8 00 00 		call	_printf
;|*** }
; Line 758
	*** 000666	c9 			leave	
	*** 000667	c3 			ret	

usage	ENDP

ExitSigHandler	PROC NEAR
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Function Name:  ExitSigHandler( int sig )
;|*** //  Description..:  This function handles Ctrl_c/Ctrl+Break while downloading.
;|*** //                  XMS must be freed or unlocked or we can't execute loadcepc
;|*** //                  again without rebooting.
;|*** //  Inputs.......:  int     sig         exit signal number
;|*** //  Outputs......:  none
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** static void ExitSigHandler( int sig )
;|*** {
; Line 772
	*** 000668	55 			push	bp
	*** 000669	8b ec 			mov	bp,sp
;	sig = 4
;|***     if( usBlockHandle )
; Line 773
	*** 00066b	83 3e 00 00 00 		cmp	WORD PTR _usBlockHandle,0
	*** 000670	74 12 			je	$I730
;|***     {
;|***         XmsUnlockExtendedMemory(usBlockHandle);
; Line 775
	*** 000672	ff 36 00 00 		push	WORD PTR _usBlockHandle
	*** 000676	e8 00 00 		call	_XmsUnlockExtendedMemory
	*** 000679	8b e5 			mov	sp,bp
;|***         XmsFreeExtendedMemory(usBlockHandle);
; Line 776
	*** 00067b	ff 36 00 00 		push	WORD PTR _usBlockHandle
	*** 00067f	e8 00 00 		call	_XmsFreeExtendedMemory
	*** 000682	8b e5 			mov	sp,bp
;|***     }
;|*** 	
;|***     exit (sig);
; Line 779
					$I730:
	*** 000684	ff 76 04 		push	WORD PTR [bp+4]	;sig
	*** 000687	e8 00 00 		call	_exit
;|*** }
; Line 780
	*** 00068a	c9 			leave	
	*** 00068b	c3 			ret	

ExitSigHandler	ENDP

DownloadRead	PROC NEAR
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Function Name:  DownloadRead( ... )
;|*** //  Description..:  This function is used to read download data. It 
;|*** //                  encapsulates the device we are reading from. 
;|*** //  Inputs.......:  int     hImage          handle to image, may be zero.
;|*** //                  UCHAR   *ucBuffer       pntr to dst buffer
;|*** //                  USHORT  usReadSize      number of bytes to read
;|*** //                  BOOL                    parallel port switch
;|*** //  Outputs......:  
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** static USHORT DownloadRead( int     hImage, 
;|***                             UCHAR  *ucBuffer, 
;|***                             USHORT  usReadSize, 
;|***                             BOOL    bParallelDownload )
;|*** {
; Line 799
	*** 00068c	55 			push	bp
	*** 00068d	8b ec 			mov	bp,sp
	*** 00068f	57 			push	di
	*** 000690	56 			push	si
;	hImage = 4
;	ucBuffer = 6
;	usReadSize = 8
;	bParallelDownload = 10
;	register si = loop
;|***     USHORT  loop;
;|*** 
;|***     if( bParallelDownload )
; Line 802
	*** 000691	83 7e 0a 00 		cmp	WORD PTR [bp+10],0	;bParallelDownload
	*** 000695	74 2b 			je	$I741
;|***     {
;|***         // Parallel download 
;|*** 
;|***         for( loop = 0; loop < usReadSize; loop++ )
; Line 806
	*** 000697	33 f6 			xor	si,si
	*** 000699	39 76 08 		cmp	WORD PTR [bp+8],si	;usReadSize
	*** 00069c	74 16 			je	$FB744
	*** 00069e	8b 7e 06 		mov	di,WORD PTR [bp+6]	;ucBuffer
					$F742:
;|***         {
;|***             ucBuffer[loop]= (UCHAR)OEMParallelPortGetByte();
; Line 808
	*** 0006a1	e8 00 00 		call	_OEMParallelPortGetByte
	*** 0006a4	88 05 			mov	BYTE PTR [di],al
;|*** 
;|***             if( NoPPFS )
; Line 810
	*** 0006a6	83 3e 00 00 00 		cmp	WORD PTR _NoPPFS,0
	*** 0006ab	75 0f 			jne	$L978
;|***         for( loop = 0; loop < usReadSize; loop++ )
; Line 806
	*** 0006ad	47 			inc	di
	*** 0006ae	46 			inc	si
	*** 0006af	3b 76 08 		cmp	si,WORD PTR [bp+8]	;usReadSize
	*** 0006b2	72 ed 			jb	$F742
					$FB744:
;|***         {
;|***             ucBuffer[loop]= (UCHAR)OEMParallelPortGetByte();
;|*** 
;|***             if( NoPPFS )
;|***             {
;|***                 return 0;
;|***             }
;|***         }
;|***         return usReadSize;
; Line 815
	*** 0006b4	8b 46 08 		mov	ax,WORD PTR [bp+8]	;usReadSize
	*** 0006b7	5e 			pop	si
	*** 0006b8	5f 			pop	di
	*** 0006b9	c9 			leave	
	*** 0006ba	c3 			ret	
	*** 0006bb	90 			nop	
					$L978:
;|***                 return 0;
; Line 812
	*** 0006bc	33 c0 			xor	ax,ax
	*** 0006be	5e 			pop	si
	*** 0006bf	5f 			pop	di
	*** 0006c0	c9 			leave	
	*** 0006c1	c3 			ret	
;|***             }
;|***         }
;|***         return usReadSize;
;|***     }
;|***     else if( bSerialDownload )
; Line 817
					$I741:
	*** 0006c2	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 0006c7	74 13 			je	$I747
	*** 0006c9	8b 76 08 		mov	si,WORD PTR [bp+8]	;usReadSize
;|***     {
;|***         // Serial download
;|*** 
;|***         OEMReadDebugBytes( ucBuffer,usReadSize );
; Line 821
	*** 0006cc	56 			push	si
	*** 0006cd	ff 76 06 		push	WORD PTR [bp+6]	;ucBuffer
	*** 0006d0	e8 00 00 		call	_OEMReadDebugBytes
	*** 0006d3	83 c4 04 		add	sp,4
;|***         return usReadSize;
; Line 822
	*** 0006d6	8b c6 			mov	ax,si
	*** 0006d8	5e 			pop	si
	*** 0006d9	5f 			pop	di
	*** 0006da	c9 			leave	
	*** 0006db	c3 			ret	
;|***     }
;|***     else
; Line 824
					$I747:
;|***     {
;|***         // Ethernet?
;|*** 
;|***         return _read( hImage, ucBuffer, usReadSize );
; Line 828
	*** 0006dc	ff 76 08 		push	WORD PTR [bp+8]	;usReadSize
	*** 0006df	ff 76 06 		push	WORD PTR [bp+6]	;ucBuffer
	*** 0006e2	ff 76 04 		push	WORD PTR [bp+4]	;hImage
	*** 0006e5	e8 00 00 		call	__read
	*** 0006e8	83 c4 06 		add	sp,6
;|***     }
;|*** }
; Line 830
	*** 0006eb	5e 			pop	si
	*** 0006ec	5f 			pop	di
	*** 0006ed	c9 			leave	
	*** 0006ee	c3 			ret	
	*** 0006ef	90 			nop	

DownloadRead	ENDP

LoadImage	PROC NEAR
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Function Name:  LoadImage
;|*** //  Description..:  This function is responsible for getting and loading 
;|*** //                  the image into memory.
;|*** //  Inputs.......:  BOOL    Verbose                 set verbose tracing flag
;|*** //                  BOOL    ParallelDownLoad        use parallel port flag
;|*** //                  char *  FileName                image file name
;|*** //                  PULONG  EntryPoint              memory entry point
;|*** //  Outputs......:  TRUE on success, FALSE on failure.
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** static int LoadImage( BOOL     bVerbose, 
;|***                       BOOL     bParallelDownload, 
;|***                       char    *pszFileName, 
;|***                       PULONG   pulEntryPoint )
;|*** {
; Line 849
	*** 0006f0	c8 80 01 00 		enter	384,0
	*** 0006f4	57 			push	di
	*** 0006f5	56 			push	si
;	ulChecksum = -36
;	usReadSize = -38
;	usAmountRead = -40
;	ulReadTotal = -44
;	ulReadProgress = -48
;	usIndex = -50
;	i = -52
;	BootPacket = -308
;	pDestByte = -310
;	pTemp = -312
;	chksum = -314
;	uiTemp = -318
;	bootType = -322
;	len = -324
;	cReturnStri = -384
;	hImage = -2
;	lImageSize = -6
;	xmsError = -8
;	usTotalFree = -10
;	usLargestBlock = -12
;	ulLinearAddress = -16
;	ulSectionAddress = -20
;	ulSectionSize = -24
;	ulSectionChecksum = -28
;	ulSectionOffset = -32
;	pulEntryPoint = 10
;	pszFileName = 8
;	bParallelDownload = 6
;	bVerbose = 4
;|***     int             hImage;
;|***     long            lImageSize;
;|***     int             xmsError;
;|***     USHORT          usTotalFree;
;|***     USHORT          usLargestBlock;
;|***     ULONG           ulLinearAddress;
;|***     ULONG           ulSectionAddress;
;|***     ULONG           ulSectionSize;
;|***     ULONG           ulSectionChecksum;
;|***     ULONG           ulSectionOffset;
;|***     ULONG           ulChecksum;
;|***     USHORT          usReadSize;
;|***     USHORT          usAmountRead;
;|***     ULONG           ulReadTotal=0;
; Line 863
	*** 0006f6	2b c0 			sub	ax,ax
	*** 0006f8	89 46 d6 		mov	WORD PTR [bp-42],ax
	*** 0006fb	89 46 d4 		mov	WORD PTR [bp-44],ax	;ulReadTotal
;|***     ULONG           ulReadProgress=0;
; Line 864
	*** 0006fe	89 46 d2 		mov	WORD PTR [bp-46],ax
	*** 000701	89 46 d0 		mov	WORD PTR [bp-48],ax	;ulReadProgress
;|***     USHORT          usIndex;
;|***     static UCHAR    ucBuffer[ CHUNKSIZE ];
;|***     static UCHAR    ucSignature[] = { 'B', '0', '0', '0', 'F', 'F', '\n'};
;|***     int             i;
;|***     UCHAR           BootPacket[256];
;|***     UCHAR           *pDestByte;
;|***     UCHAR           *pTemp;
;|***     unsigned int    chksum;
;|***     long int        uiTemp;
;|***     long int        bootType;
;|***     unsigned        len;
;|*** 
;|*** 	char cReturnStri[60]={0};
; Line 877
	*** 000704	88 86 80 fe 		mov	BYTE PTR [bp-384],al	;cReturnStri
	*** 000708	b9 1d 00 		mov	cx,29	;001dH
	*** 00070b	8d be 81 fe 		lea	di,WORD PTR [bp-383]
	*** 00070f	16 			push	ss
	*** 000710	07 			pop	es
	*** 000711	f3 			rep
	*** 000712	ab 			stosw
	*** 000713	aa 			stosb
;|*** 	strcpy(cReturnStri,"\r                                                                         \r\n        ");
; Line 878
	*** 000714	8d be 80 fe 		lea	di,WORD PTR [bp-384]	;cReturnStri
	*** 000718	be 00 00 		mov	si,OFFSET DGROUP:$SG787
	*** 00071b	b9 2a 00 		mov	cx,42	;002aH
	*** 00071e	f3 			rep
	*** 00071f	a5 			movsw
	*** 000720	a4 			movsb
;|*** 
;|***     // Find the largest Extended Memory block and allocate it
;|*** 
;|***     xmsError = XmsQueryFreeExtendedMemory(&usLargestBlock, &usTotalFree);
;|*** 
;|***     if( xmsError != XMS_SUCCESS )
; Line 884
	*** 000721	8d 4e f6 		lea	cx,WORD PTR [bp-10]	;usTotalFree
	*** 000724	51 			push	cx
	*** 000725	8d 4e f4 		lea	cx,WORD PTR [bp-12]	;usLargestBlock
	*** 000728	51 			push	cx
	*** 000729	e8 00 00 		call	_XmsQueryFreeExtendedMemory
	*** 00072c	83 c4 04 		add	sp,4
	*** 00072f	89 46 f8 		mov	WORD PTR [bp-8],ax	;xmsError
	*** 000732	0b c0 			or	ax,ax
	*** 000734	74 2e 			je	$I788
;|***     { 
;|***         printf("Error querying free extended memory - %s\n", XmsErrorString(xmsError));
; Line 886
	*** 000736	50 			push	ax
	*** 000737	e8 00 00 		call	_XmsErrorString
	*** 00073a	83 c4 02 		add	sp,2
	*** 00073d	50 			push	ax
	*** 00073e	68 00 00 		push	OFFSET DGROUP:$SG789
					$L1015:
	*** 000741	e8 00 00 		call	_printf
	*** 000744	83 c4 04 		add	sp,4
;|*** 
;|***         if( !bParallelDownload && !bSerialDownload )
; Line 888
					$L1016:
	*** 000747	83 7e 06 00 		cmp	WORD PTR [bp+6],0	;bParallelDownload
	*** 00074b	75 10 			jne	$I790
	*** 00074d	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 000752	75 09 			jne	$I790
;|***         {
;|***             _close(hImage);
; Line 890
	*** 000754	ff 76 fe 		push	WORD PTR [bp-2]	;hImage
	*** 000757	e8 00 00 		call	__close
	*** 00075a	83 c4 02 		add	sp,2
;|***         }
;|*** 
;|***         return FALSE;
; Line 893
					$I790:
	*** 00075d	33 c0 			xor	ax,ax
	*** 00075f	5e 			pop	si
	*** 000760	5f 			pop	di
	*** 000761	c9 			leave	
	*** 000762	c3 			ret	
	*** 000763	90 			nop	
;|***     }
;|*** 
;|*** 	printf("               ImageName:......: %s\n",pszFileName );
; Line 896
					$I788:
	*** 000764	ff 76 08 		push	WORD PTR [bp+8]	;pszFileName
	*** 000767	68 00 00 		push	OFFSET DGROUP:$SG791
	*** 00076a	e8 00 00 		call	_printf
	*** 00076d	83 c4 04 		add	sp,4
;|*** 	printf("               FLATMode........: %d\n",iDesiredMode);
; Line 897
	*** 000770	ff 36 00 00 		push	WORD PTR _iDesiredMode
	*** 000774	68 00 00 		push	OFFSET DGROUP:$SG792
	*** 000777	e8 00 00 		call	_printf
	*** 00077a	83 c4 04 		add	sp,4
;|***     printf("               VESAMode........: 0x%x\n", BootArgs.vesaMode );
; Line 898
	*** 00077d	ff 36 6c 00 		push	WORD PTR _BootArgs+108
	*** 000781	68 00 00 		push	OFFSET DGROUP:$SG793
	*** 000784	e8 00 00 		call	_printf
	*** 000787	83 c4 04 		add	sp,4
;|*** 	printf("               FreeEMSMem......: %u\n",usTotalFree);
; Line 899
	*** 00078a	ff 76 f6 		push	WORD PTR [bp-10]	;usTotalFree
	*** 00078d	68 00 00 		push	OFFSET DGROUP:$SG794
	*** 000790	e8 00 00 		call	_printf
	*** 000793	83 c4 04 		add	sp,4
;|*** 	printf("               LagestBlock.....: %u\n",usLargestBlock);
; Line 900
	*** 000796	ff 76 f4 		push	WORD PTR [bp-12]	;usLargestBlock
	*** 000799	68 00 00 		push	OFFSET DGROUP:$SG795
	*** 00079c	e8 00 00 		call	_printf
	*** 00079f	83 c4 04 		add	sp,4
;|*** 	printf("             ==========Booting - Press CTRL+C to cancel=========\n ");
; Line 901
	*** 0007a2	68 00 00 		push	OFFSET DGROUP:$SG796
	*** 0007a5	e8 00 00 		call	_printf
	*** 0007a8	83 c4 02 		add	sp,2
;|*** 	fprintf(stderr, "                            ");
; Line 902
	*** 0007ab	68 00 00 		push	OFFSET DGROUP:$SG797
	*** 0007ae	68 10 00 		push	OFFSET __iob+16
	*** 0007b1	e8 00 00 		call	_fprintf
	*** 0007b4	83 c4 04 		add	sp,4
;|*** 	fprintf(stderr, "             ");
; Line 903
	*** 0007b7	68 00 00 		push	OFFSET DGROUP:$SG798
	*** 0007ba	68 10 00 		push	OFFSET __iob+16
	*** 0007bd	e8 00 00 		call	_fprintf
	*** 0007c0	83 c4 04 		add	sp,4
;|***     if( bVerbose )
; Line 904
	*** 0007c3	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;bVerbose
	*** 0007c7	74 1d 			je	$I799
;|***     {
;|*** 		fprintf(stderr,cReturnStri);
; Line 906
	*** 0007c9	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 0007cd	50 			push	ax
	*** 0007ce	68 10 00 		push	OFFSET __iob+16
	*** 0007d1	e8 00 00 		call	_fprintf
	*** 0007d4	83 c4 04 		add	sp,4
;|***         // Print info about memory available
;|***         printf( "Total free extended memory = %u, largest block = %u\n",
;|***                 usTotalFree, usLargestBlock);
; Line 909
	*** 0007d7	ff 76 f4 		push	WORD PTR [bp-12]	;usLargestBlock
	*** 0007da	ff 76 f6 		push	WORD PTR [bp-10]	;usTotalFree
	*** 0007dd	68 00 00 		push	OFFSET DGROUP:$SG800
	*** 0007e0	e8 00 00 		call	_printf
	*** 0007e3	83 c4 06 		add	sp,6
;|***     }
;|*** 
;|***     // Allocate the extended block
;|*** 
;|***     xmsError = XmsAllocateExtendedMemory(usLargestBlock, &usBlockHandle);
; Line 914
					$I799:
;|*** 
;|***     if( xmsError != XMS_SUCCESS )
; Line 916
	*** 0007e6	68 00 00 		push	OFFSET DGROUP:_usBlockHandle
	*** 0007e9	ff 76 f4 		push	WORD PTR [bp-12]	;usLargestBlock
	*** 0007ec	e8 00 00 		call	_XmsAllocateExtendedMemory
	*** 0007ef	83 c4 04 		add	sp,4
	*** 0007f2	89 46 f8 		mov	WORD PTR [bp-8],ax	;xmsError
	*** 0007f5	0b c0 			or	ax,ax
	*** 0007f7	74 1f 			je	$I801
;|***     {
;|*** 		fprintf(stderr,cReturnStri);
; Line 918
	*** 0007f9	8d 8e 80 fe 		lea	cx,WORD PTR [bp-384]	;cReturnStri
	*** 0007fd	51 			push	cx
	*** 0007fe	68 10 00 		push	OFFSET __iob+16
	*** 000801	e8 00 00 		call	_fprintf
	*** 000804	83 c4 04 		add	sp,4
;|***         printf( "Error allocating extended memory - %s\n", 
;|***                XmsErrorString(xmsError));
; Line 920
	*** 000807	ff 76 f8 		push	WORD PTR [bp-8]	;xmsError
	*** 00080a	e8 00 00 		call	_XmsErrorString
	*** 00080d	83 c4 02 		add	sp,2
	*** 000810	50 			push	ax
	*** 000811	68 00 00 		push	OFFSET DGROUP:$SG802
	*** 000814	e9 2a ff 		jmp	$L1015
	*** 000817	90 			nop	
;|*** 
;|***         if( !bParallelDownload && !bSerialDownload )
;|***         {
;|***             _close(hImage);
;|***         }
;|*** 
;|***         return FALSE;
;|***     }
;|*** 
;|***     //printf("XMS usBlockHandle = 0x%x\n", usBlockHandle);
;|*** 
;|***     // Lock the block and obtain its linear address.  
;|***     // Then ensure that the image fits into it.
;|*** 
;|***     xmsError = XmsLockExtendedMemory(usBlockHandle, &ulLinearAddress);
; Line 935
					$I801:
;|*** 
;|***     if( xmsError != XMS_SUCCESS )
; Line 937
	*** 000818	8d 46 f0 		lea	ax,WORD PTR [bp-16]	;ulLinearAddress
	*** 00081b	50 			push	ax
	*** 00081c	ff 36 00 00 		push	WORD PTR _usBlockHandle
	*** 000820	e8 00 00 		call	_XmsLockExtendedMemory
	*** 000823	83 c4 04 		add	sp,4
	*** 000826	89 46 f8 		mov	WORD PTR [bp-8],ax	;xmsError
	*** 000829	0b c0 			or	ax,ax
	*** 00082b	74 35 			je	$I804
;|***     {
;|***         fprintf(stderr,cReturnStri);
; Line 939
	*** 00082d	8d 8e 80 fe 		lea	cx,WORD PTR [bp-384]	;cReturnStri
	*** 000831	51 			push	cx
	*** 000832	68 10 00 		push	OFFSET __iob+16
	*** 000835	e8 00 00 		call	_fprintf
	*** 000838	83 c4 04 		add	sp,4
;|***         printf("Error locking extended memory - %s\n", XmsErrorString(xmsError));
; Line 940
	*** 00083b	ff 76 f8 		push	WORD PTR [bp-8]	;xmsError
	*** 00083e	e8 00 00 		call	_XmsErrorString
	*** 000841	83 c4 02 		add	sp,2
	*** 000844	50 			push	ax
	*** 000845	68 00 00 		push	OFFSET DGROUP:$SG805
	*** 000848	e8 00 00 		call	_printf
	*** 00084b	83 c4 04 		add	sp,4
;|*** 
;|***         XmsFreeExtendedMemory(usBlockHandle);
; Line 942
	*** 00084e	ff 36 00 00 		push	WORD PTR _usBlockHandle
	*** 000852	e8 00 00 		call	_XmsFreeExtendedMemory
	*** 000855	83 c4 02 		add	sp,2
;|***         usBlockHandle = 0;
; Line 943
	*** 000858	c7 06 00 00 00 00 	mov	WORD PTR _usBlockHandle,0
	*** 00085e	e9 e6 fe 		jmp	$L1016
	*** 000861	90 			nop	
;|*** 
;|***         if( !bParallelDownload && !bSerialDownload )
;|***         {
;|***             _close(hImage);
;|***         }
;|*** 
;|***         return FALSE;
;|***     }
;|*** 
;|***     // Print info about block allocated
;|*** 
;|***     if( bVerbose )
; Line 955
					$I804:
	*** 000862	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;bVerbose
	*** 000866	74 1d 			je	$I807
;|***     {
;|***         fprintf(stderr,cReturnStri);
; Line 957
	*** 000868	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 00086c	50 			push	ax
	*** 00086d	68 10 00 		push	OFFSET __iob+16
	*** 000870	e8 00 00 		call	_fprintf
	*** 000873	83 c4 04 		add	sp,4
;|***         printf("Block allocated at 0x%lX\n", ulLinearAddress);
; Line 958
	*** 000876	ff 76 f2 		push	WORD PTR [bp-14]
	*** 000879	ff 76 f0 		push	WORD PTR [bp-16]	;ulLinearAddress
	*** 00087c	68 00 00 		push	OFFSET DGROUP:$SG808
	*** 00087f	e8 00 00 		call	_printf
	*** 000882	83 c4 06 		add	sp,6
;|***     }
;|*** 
;|***     // Zero upper memory in CHUNKSIZE chunks
;|*** 
;|***     memset(ucBuffer, 0, sizeof(ucBuffer));
; Line 963
					$I807:
	*** 000885	33 c0 			xor	ax,ax
	*** 000887	bb 00 00 		mov	bx,OFFSET DGROUP:$S775_?ucBuffer@?1??LoadImage@@9@9
	*** 00088a	b9 00 40 		mov	cx,16384	;4000H
	*** 00088d	8b fb 			mov	di,bx
	*** 00088f	1e 			push	ds
	*** 000890	07 			pop	es
	*** 000891	f3 			rep
	*** 000892	ab 			stosw
;|***     ulSectionSize = (ULONG)usLargestBlock * 1024;
; Line 964
	*** 000893	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;usLargestBlock
	*** 000896	2b d2 			sub	dx,dx
	*** 000898	8a d4 			mov	dl,ah
	*** 00089a	8a e0 			mov	ah,al
	*** 00089c	2a c0 			sub	al,al
	*** 00089e	03 c0 			add	ax,ax
	*** 0008a0	13 d2 			adc	dx,dx
	*** 0008a2	03 c0 			add	ax,ax
	*** 0008a4	13 d2 			adc	dx,dx
	*** 0008a6	89 46 e8 		mov	WORD PTR [bp-24],ax	;ulSectionSize
	*** 0008a9	89 56 ea 		mov	WORD PTR [bp-22],dx
;|*** 
;|***     for( ulSectionOffset = 0; ulSectionOffset < ulSectionSize; ulSectionOffset += usReadSize )
; Line 966
	*** 0008ac	2b c0 			sub	ax,ax
	*** 0008ae	89 46 e2 		mov	WORD PTR [bp-30],ax
	*** 0008b1	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulSectionOffset
	*** 0008b4	eb 51 			jmp	SHORT $F809
					$I812:
;|***     {
;|***         if( (ulSectionSize - ulSectionOffset) < CHUNKSIZE )
;|***         {
;|***             usReadSize = (USHORT)(ulSectionSize - ulSectionOffset);
;|***         }
;|***         else
;|***         {
;|***             usReadSize = CHUNKSIZE;
; Line 974
	*** 0008b6	c7 46 da 00 80 		mov	WORD PTR [bp-38],-32768	;8000H	;usReadSize
;|***         }
; Line 975
					$I813:
;|*** 
;|***         xmsError = XmsMoveExtendedMemory(
;|***                                         0, (ULONG)(UCHAR far *)ucBuffer,
;|***                                         usBlockHandle, ulSectionOffset, usReadSize);
;|*** 
;|***         if( xmsError != XMS_SUCCESS )
; Line 981
	*** 0008bb	6a 00 			push	0
	*** 0008bd	ff 76 da 		push	WORD PTR [bp-38]	;usReadSize
	*** 0008c0	ff 76 e2 		push	WORD PTR [bp-30]
	*** 0008c3	ff 76 e0 		push	WORD PTR [bp-32]	;ulSectionOffset
	*** 0008c6	ff 36 00 00 		push	WORD PTR _usBlockHandle
	*** 0008ca	1e 			push	ds
	*** 0008cb	68 00 00 		push	OFFSET DGROUP:$S775_?ucBuffer@?1??LoadImage@@9@9
	*** 0008ce	6a 00 			push	0
	*** 0008d0	e8 00 00 		call	_XmsMoveExtendedMemory
	*** 0008d3	83 c4 10 		add	sp,16	;0010H
	*** 0008d6	89 46 f8 		mov	WORD PTR [bp-8],ax	;xmsError
	*** 0008d9	0b c0 			or	ax,ax
	*** 0008db	74 1f 			je	$FC810
;|***         {
;|***             fprintf(stderr,cReturnStri);
; Line 983
	*** 0008dd	8d 8e 80 fe 		lea	cx,WORD PTR [bp-384]	;cReturnStri
	*** 0008e1	51 			push	cx
	*** 0008e2	68 10 00 		push	OFFSET __iob+16
	*** 0008e5	e8 00 00 		call	_fprintf
	*** 0008e8	83 c4 04 		add	sp,4
;|***             printf("Error zeroing extended memory - %s\n", XmsErrorString(xmsError));
; Line 984
	*** 0008eb	ff 76 f8 		push	WORD PTR [bp-8]	;xmsError
	*** 0008ee	e8 00 00 		call	_XmsErrorString
	*** 0008f1	83 c4 02 		add	sp,2
	*** 0008f4	50 			push	ax
	*** 0008f5	68 00 00 		push	OFFSET DGROUP:$SG815
	*** 0008f8	e9 46 fe 		jmp	$L1015
;|***             if( !bParallelDownload && !bSerialDownload )
;|***                 _close(hImage);
;|*** 
;|***             return FALSE;
;|***         }
;|***     }
; Line 990
	*** 0008fb	90 			nop	
					$FC810:
	*** 0008fc	8b 46 da 		mov	ax,WORD PTR [bp-38]	;usReadSize
	*** 0008ff	2b d2 			sub	dx,dx
	*** 000901	01 46 e0 		add	WORD PTR [bp-32],ax	;ulSectionOffset
	*** 000904	11 56 e2 		adc	WORD PTR [bp-30],dx
					$F809:
	*** 000907	8b 46 e8 		mov	ax,WORD PTR [bp-24]	;ulSectionSize
	*** 00090a	8b 56 ea 		mov	dx,WORD PTR [bp-22]
	*** 00090d	39 56 e2 		cmp	WORD PTR [bp-30],dx
	*** 000910	77 22 			ja	$FB811
	*** 000912	72 05 			jb	$L980
	*** 000914	39 46 e0 		cmp	WORD PTR [bp-32],ax	;ulSectionOffset
	*** 000917	73 1b 			jae	$FB811
					$L980:
;|***         if( (ulSectionSize - ulSectionOffset) < CHUNKSIZE )
; Line 968
	*** 000919	2b 46 e0 		sub	ax,WORD PTR [bp-32]	;ulSectionOffset
	*** 00091c	1b 56 e2 		sbb	dx,WORD PTR [bp-30]
	*** 00091f	0b d2 			or	dx,dx
	*** 000921	75 93 			jne	$I812
	*** 000923	3d 00 80 		cmp	ax,-32768	;8000H
	*** 000926	73 8e 			jae	$I812
;|***         {
;|***             usReadSize = (USHORT)(ulSectionSize - ulSectionOffset);
; Line 970
	*** 000928	8b 46 e8 		mov	ax,WORD PTR [bp-24]	;ulSectionSize
	*** 00092b	2b 46 e0 		sub	ax,WORD PTR [bp-32]	;ulSectionOffset
	*** 00092e	89 46 da 		mov	WORD PTR [bp-38],ax	;usReadSize
;|***         }
;|***         else
; Line 972
	*** 000931	eb 88 			jmp	SHORT $I813
	*** 000933	90 			nop	
					$FB811:
;|***         {
;|***             usReadSize = CHUNKSIZE;
;|***         }
;|*** 
;|***         xmsError = XmsMoveExtendedMemory(
;|***                                         0, (ULONG)(UCHAR far *)ucBuffer,
;|***                                         usBlockHandle, ulSectionOffset, usReadSize);
;|*** 
;|***         if( xmsError != XMS_SUCCESS )
;|***         {
;|***             fprintf(stderr,cReturnStri);
;|***             printf("Error zeroing extended memory - %s\n", XmsErrorString(xmsError));
;|***             if( !bParallelDownload && !bSerialDownload )
;|***                 _close(hImage);
;|*** 
;|***             return FALSE;
;|***         }
;|***     }
;|*** 
;|***     // Open image file
;|*** 
;|***     // If this is a serial download, initialize the serial port
;|*** 
;|***     if( bSerialDownload )
; Line 996
	*** 000934	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 000939	74 03 			je	$I817
;|***     {
;|***         OEMInitDebugSerial();
; Line 998
	*** 00093b	e8 00 00 		call	_OEMInitDebugSerial
;|***     }
;|*** 
;|***     if( bParallelDownload || bSerialDownload )
; Line 1001
					$I817:
	*** 00093e	83 7e 06 00 		cmp	WORD PTR [bp+6],0	;bParallelDownload
	*** 000942	75 0a 			jne	$I819
	*** 000944	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 000949	75 03 			jne	$JCC2377
	*** 00094b	e9 6a 02 		jmp	$I818
					$JCC2377:
					$I819:
;|***     {
;|***         // Prepare boot packet
;|***         
;|***         pDestByte = BootPacket;
; Line 1005
	*** 00094e	8d 86 cc fe 		lea	ax,WORD PTR [bp-308]	;BootPacket
	*** 000952	89 86 ca fe 		mov	WORD PTR [bp-310],ax	;pDestByte
;|*** 
;|***         for( i = 0; i < BOOT_HEADER_SIZE; i++ )
; Line 1007
	*** 000956	c7 46 cc 00 00 		mov	WORD PTR [bp-52],0	;i
					$FC821:
;|***         {
;|***             *pDestByte++ = BootHeader[i];
; Line 1009
	*** 00095b	8b 5e cc 		mov	bx,WORD PTR [bp-52]	;i
	*** 00095e	8a 87 00 00 		mov	al,BYTE PTR $S519_BootHeader[bx]
	*** 000962	8b 9e ca fe 		mov	bx,WORD PTR [bp-310]	;pDestByte
	*** 000966	ff 86 ca fe 		inc	WORD PTR [bp-310]	;pDestByte
	*** 00096a	88 07 			mov	BYTE PTR [bx],al
;|***         }
; Line 1010
	*** 00096c	ff 46 cc 		inc	WORD PTR [bp-52]	;i
	*** 00096f	83 7e cc 06 		cmp	WORD PTR [bp-52],6	;i
	*** 000973	72 e6 			jb	$FC821
;|*** 
;|***         chksum = 0;
; Line 1012
	*** 000975	c7 86 c6 fe 00 00 	mov	WORD PTR [bp-314],0	;chksum
;|***         len = 9;
; Line 1013
	*** 00097b	c7 86 bc fe 09 00 	mov	WORD PTR [bp-324],9	;len
;|*** 
;|***         if( pszFileName )
; Line 1015
	*** 000981	83 7e 08 00 		cmp	WORD PTR [bp+8],0	;pszFileName
	*** 000985	74 61 			je	$I823
;|***         {
;|*** 			fprintf(stderr,cReturnStri);
; Line 1017
	*** 000987	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 00098b	50 			push	ax
	*** 00098c	68 10 00 		push	OFFSET __iob+16
	*** 00098f	e8 00 00 		call	_fprintf
	*** 000992	83 c4 04 		add	sp,4
;|***             if( bSerialDownload )
; Line 1018
	*** 000995	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 00099a	74 08 			je	$I824
;|***                 printf("Loading image %s via serial port.\r\n",pszFileName);
; Line 1019
	*** 00099c	ff 76 08 		push	WORD PTR [bp+8]	;pszFileName
	*** 00099f	68 00 00 		push	OFFSET DGROUP:$SG825
	*** 0009a2	eb 06 			jmp	SHORT $L1005
					$I824:
;|***             else
;|***                 printf("Loading image %s via parallel port.\r\n",pszFileName);
; Line 1021
	*** 0009a4	ff 76 08 		push	WORD PTR [bp+8]	;pszFileName
	*** 0009a7	68 00 00 		push	OFFSET DGROUP:$SG827
					$L1005:
	*** 0009aa	e8 00 00 		call	_printf
	*** 0009ad	83 c4 04 		add	sp,4
;|*** 
;|***             bootType = 1;              // The NULL byte
; Line 1023
	*** 0009b0	c7 86 be fe 01 00 	mov	WORD PTR [bp-322],1	;bootType
	*** 0009b6	c7 86 c0 fe 00 00 	mov	WORD PTR [bp-320],0
;|*** 
;|***             for( pTemp = (UCHAR*)pszFileName; *pTemp; pTemp++ )
; Line 1025
	*** 0009bc	8b 46 08 		mov	ax,WORD PTR [bp+8]	;pszFileName
	*** 0009bf	89 86 c8 fe 		mov	WORD PTR [bp-312],ax	;pTemp
	*** 0009c3	eb 0f 			jmp	SHORT $F828
	*** 0009c5	90 			nop	
					$FC829:
;|***             {
;|***                 bootType++;
; Line 1027
	*** 0009c6	83 86 be fe 01 		add	WORD PTR [bp-322],1	;bootType
	*** 0009cb	83 96 c0 fe 00 		adc	WORD PTR [bp-320],0
;|***             }
; Line 1028
	*** 0009d0	ff 86 c8 fe 		inc	WORD PTR [bp-312]	;pTemp
					$F828:
	*** 0009d4	8b 9e c8 fe 		mov	bx,WORD PTR [bp-312]	;pTemp
	*** 0009d8	80 3f 00 		cmp	BYTE PTR [bx],0
	*** 0009db	75 e9 			jne	$FC829
;|*** 
;|***             len += (unsigned)bootType;
; Line 1030
	*** 0009dd	8b 86 be fe 		mov	ax,WORD PTR [bp-322]	;bootType
	*** 0009e1	01 86 bc fe 		add	WORD PTR [bp-324],ax	;len
;|*** 
;|***         }
;|***         else
; Line 1033
	*** 0009e5	eb 30 			jmp	SHORT $I831
	*** 0009e7	90 			nop	
					$I823:
;|***         {
;|*** 			fprintf(stderr,cReturnStri);
; Line 1035
	*** 0009e8	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 0009ec	50 			push	ax
	*** 0009ed	68 10 00 		push	OFFSET __iob+16
	*** 0009f0	e8 00 00 		call	_fprintf
	*** 0009f3	83 c4 04 		add	sp,4
;|***             if( bSerialDownload )
; Line 1036
	*** 0009f6	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 0009fb	74 05 			je	$I832
;|***                 printf("Loading host default image via serial port.\r\n");
; Line 1037
	*** 0009fd	68 00 00 		push	OFFSET DGROUP:$SG833
	*** 000a00	eb 03 			jmp	SHORT $L1007
					$I832:
;|***             else
;|***                 printf("Loading host default image via parallel port.\r\n");
; Line 1039
	*** 000a02	68 00 00 		push	OFFSET DGROUP:$SG835
					$L1007:
	*** 000a05	e8 00 00 		call	_printf
	*** 000a08	83 c4 02 		add	sp,2
;|*** 
;|***             bootType = BOOT_TYPE;
; Line 1041
	*** 000a0b	c7 86 be fe fc ff 	mov	WORD PTR [bp-322],-4	;fffcH	;bootType
	*** 000a11	c7 86 c0 fe ff ff 	mov	WORD PTR [bp-320],-1	;ffffH
;|***         }
; Line 1042
					$I831:
;|*** 
;|***         uiTemp = len;
; Line 1044
	*** 000a17	8b 86 bc fe 		mov	ax,WORD PTR [bp-324]	;len
	*** 000a1b	89 86 c2 fe 		mov	WORD PTR [bp-318],ax	;uiTemp
	*** 000a1f	c7 86 c4 fe 00 00 	mov	WORD PTR [bp-316],0
;|*** 
;|***         for( i = 0; i < 2; i++ )
; Line 1046
	*** 000a25	c7 46 cc 00 00 		mov	WORD PTR [bp-52],0	;i
					$FC837:
;|***         {
;|***             *pDestByte++ = (unsigned char)(uiTemp & 0xFF);
; Line 1048
	*** 000a2a	8b c8 			mov	cx,ax
	*** 000a2c	8b 9e ca fe 		mov	bx,WORD PTR [bp-310]	;pDestByte
	*** 000a30	ff 86 ca fe 		inc	WORD PTR [bp-310]	;pDestByte
	*** 000a34	88 07 			mov	BYTE PTR [bx],al
;|***             chksum += (unsigned int)(uiTemp & 0xFF);
; Line 1049
	*** 000a36	2a ed 			sub	ch,ch
	*** 000a38	01 8e c6 fe 		add	WORD PTR [bp-314],cx	;chksum
;|***             uiTemp >>= 8;
; Line 1050
	*** 000a3c	8b 86 c2 fe 		mov	ax,WORD PTR [bp-318]	;uiTemp
	*** 000a40	8b 96 c4 fe 		mov	dx,WORD PTR [bp-316]
	*** 000a44	8a c4 			mov	al,ah
	*** 000a46	8a e2 			mov	ah,dl
	*** 000a48	8a d6 			mov	dl,dh
	*** 000a4a	02 f6 			add	dh,dh
	*** 000a4c	1a f6 			sbb	dh,dh
	*** 000a4e	89 86 c2 fe 		mov	WORD PTR [bp-318],ax	;uiTemp
	*** 000a52	89 96 c4 fe 		mov	WORD PTR [bp-316],dx
;|***         }
; Line 1051
	*** 000a56	ff 46 cc 		inc	WORD PTR [bp-52]	;i
	*** 000a59	83 7e cc 02 		cmp	WORD PTR [bp-52],2	;i
	*** 000a5d	7c cb 			jl	$FC837
;|*** 
;|***         uiTemp = bootType;
; Line 1053
	*** 000a5f	8b 86 be fe 		mov	ax,WORD PTR [bp-322]	;bootType
	*** 000a63	8b 96 c0 fe 		mov	dx,WORD PTR [bp-320]
	*** 000a67	89 86 c2 fe 		mov	WORD PTR [bp-318],ax	;uiTemp
	*** 000a6b	89 96 c4 fe 		mov	WORD PTR [bp-316],dx
;|*** 
;|***         for( i = 0; i < 4; i++ )
; Line 1055
	*** 000a6f	c7 46 cc 00 00 		mov	WORD PTR [bp-52],0	;i
					$FC840:
;|***         {
;|***             *pDestByte++ = (unsigned char)(uiTemp & 0xFF);
; Line 1057
	*** 000a74	8b c8 			mov	cx,ax
	*** 000a76	8b 9e ca fe 		mov	bx,WORD PTR [bp-310]	;pDestByte
	*** 000a7a	ff 86 ca fe 		inc	WORD PTR [bp-310]	;pDestByte
	*** 000a7e	88 07 			mov	BYTE PTR [bx],al
;|***             chksum += (unsigned int)(uiTemp & 0xFF);
; Line 1058
	*** 000a80	2a ed 			sub	ch,ch
	*** 000a82	01 8e c6 fe 		add	WORD PTR [bp-314],cx	;chksum
;|***             uiTemp >>= 8;
; Line 1059
	*** 000a86	8b 86 c2 fe 		mov	ax,WORD PTR [bp-318]	;uiTemp
	*** 000a8a	8b 96 c4 fe 		mov	dx,WORD PTR [bp-316]
	*** 000a8e	8a c4 			mov	al,ah
	*** 000a90	8a e2 			mov	ah,dl
	*** 000a92	8a d6 			mov	dl,dh
	*** 000a94	02 f6 			add	dh,dh
	*** 000a96	1a f6 			sbb	dh,dh
	*** 000a98	89 86 c2 fe 		mov	WORD PTR [bp-318],ax	;uiTemp
	*** 000a9c	89 96 c4 fe 		mov	WORD PTR [bp-316],dx
;|***         }
; Line 1060
	*** 000aa0	ff 46 cc 		inc	WORD PTR [bp-52]	;i
	*** 000aa3	83 7e cc 04 		cmp	WORD PTR [bp-52],4	;i
	*** 000aa7	7c cb 			jl	$FC840
;|*** 
;|***         if( bootType > 0 )
; Line 1062
	*** 000aa9	83 be c0 fe 00 		cmp	WORD PTR [bp-320],0
	*** 000aae	7c 3e 			jl	$I842
	*** 000ab0	7f 07 			jg	$L982
	*** 000ab2	83 be be fe 00 		cmp	WORD PTR [bp-322],0	;bootType
	*** 000ab7	74 35 			je	$I842
					$L982:
;|***         {
;|***             for( pTemp = (UCHAR*)pszFileName; *pTemp; pTemp++ )
; Line 1064
	*** 000ab9	8b 46 08 		mov	ax,WORD PTR [bp+8]	;pszFileName
	*** 000abc	89 86 c8 fe 		mov	WORD PTR [bp-312],ax	;pTemp
	*** 000ac0	eb 18 			jmp	SHORT $F843
					$FC844:
;|***             {
;|***                 *pDestByte++ = *pTemp;
; Line 1066
	*** 000ac2	8a 07 			mov	al,BYTE PTR [bx]
	*** 000ac4	8b b6 ca fe 		mov	si,WORD PTR [bp-310]	;pDestByte
	*** 000ac8	ff 86 ca fe 		inc	WORD PTR [bp-310]	;pDestByte
	*** 000acc	88 04 			mov	BYTE PTR [si],al
;|***                 chksum += *pTemp;
; Line 1067
	*** 000ace	8a 07 			mov	al,BYTE PTR [bx]
	*** 000ad0	2a e4 			sub	ah,ah
	*** 000ad2	01 86 c6 fe 		add	WORD PTR [bp-314],ax	;chksum
;|***             }
; Line 1068
	*** 000ad6	ff 86 c8 fe 		inc	WORD PTR [bp-312]	;pTemp
					$F843:
	*** 000ada	8b 9e c8 fe 		mov	bx,WORD PTR [bp-312]	;pTemp
	*** 000ade	80 3f 00 		cmp	BYTE PTR [bx],0
	*** 000ae1	75 df 			jne	$FC844
;|***             *pDestByte++ = 0;
; Line 1069
	*** 000ae3	8b 9e ca fe 		mov	bx,WORD PTR [bp-310]	;pDestByte
	*** 000ae7	ff 86 ca fe 		inc	WORD PTR [bp-310]	;pDestByte
	*** 000aeb	c6 07 00 		mov	BYTE PTR [bx],0
;|***         }
;|*** 
;|***         *pDestByte++ = (unsigned char)((~chksum) & 0xFF);
; Line 1072
					$I842:
	*** 000aee	8a 86 c6 fe 		mov	al,BYTE PTR [bp-314]	;chksum
	*** 000af2	f6 d0 			not	al
	*** 000af4	8b 9e ca fe 		mov	bx,WORD PTR [bp-310]	;pDestByte
	*** 000af8	ff 86 ca fe 		inc	WORD PTR [bp-310]	;pDestByte
	*** 000afc	88 07 			mov	BYTE PTR [bx],al
;|*** 
;|***         for( i = 0; i < BOOT_TAIL_SIZE; i++ )
; Line 1074
	*** 000afe	c7 46 cc 00 00 		mov	WORD PTR [bp-52],0	;i
					$FC847:
;|***         {
;|***             *pDestByte++ = BootTail[i];
; Line 1076
	*** 000b03	8b 5e cc 		mov	bx,WORD PTR [bp-52]	;i
	*** 000b06	8a 87 00 00 		mov	al,BYTE PTR $S520_BootTail[bx]
	*** 000b0a	8b 9e ca fe 		mov	bx,WORD PTR [bp-310]	;pDestByte
	*** 000b0e	ff 86 ca fe 		inc	WORD PTR [bp-310]	;pDestByte
	*** 000b12	88 07 			mov	BYTE PTR [bx],al
;|***         }
; Line 1077
	*** 000b14	ff 46 cc 		inc	WORD PTR [bp-52]	;i
	*** 000b17	83 7e cc 04 		cmp	WORD PTR [bp-52],4	;i
	*** 000b1b	72 e6 			jb	$FC847
;|*** 
;|*** 
;|***         if( bVerbose ) 
; Line 1080
	*** 000b1d	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;bVerbose
	*** 000b21	74 17 			je	$I849
;|*** 		{
;|*** 			fprintf(stderr,cReturnStri);
; Line 1082
	*** 000b23	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000b27	50 			push	ax
	*** 000b28	68 10 00 		push	OFFSET __iob+16
	*** 000b2b	e8 00 00 		call	_fprintf
	*** 000b2e	83 c4 04 		add	sp,4
;|*** 			printf("Sending boot packet: ");
; Line 1083
	*** 000b31	68 00 00 		push	OFFSET DGROUP:$SG850
	*** 000b34	e8 00 00 		call	_printf
	*** 000b37	83 c4 02 		add	sp,2
;|*** 		}
;|*** 
;|***         usIndex=0;
; Line 1086
					$I849:
	*** 000b3a	c7 46 ce 00 00 		mov	WORD PTR [bp-50],0	;usIndex
;|*** 
;|***         while( &BootPacket[usIndex] < pDestByte )
; Line 1088
	*** 000b3f	eb 58 			jmp	SHORT $L1013
	*** 000b41	90 			nop	
					$FC852:
;|***         {
;|***             if( NoPPFS )
; Line 1090
	*** 000b42	83 3e 00 00 00 		cmp	WORD PTR _NoPPFS,0
	*** 000b47	74 03 			je	$JCC2887
	*** 000b49	e9 11 fc 		jmp	$I790
					$JCC2887:
;|***             {
;|***                 return FALSE;
;|***             }
;|*** 
;|***             if( bVerbose ) 
; Line 1095
	*** 000b4c	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;bVerbose
	*** 000b50	74 21 			je	$I855
;|*** 			{
;|*** 				fprintf(stderr,cReturnStri);
; Line 1097
	*** 000b52	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000b56	50 			push	ax
	*** 000b57	68 10 00 		push	OFFSET __iob+16
	*** 000b5a	e8 00 00 		call	_fprintf
	*** 000b5d	83 c4 04 		add	sp,4
;|*** 				printf("%x ",BootPacket[usIndex]);
; Line 1098
	*** 000b60	8b 76 ce 		mov	si,WORD PTR [bp-50]	;usIndex
	*** 000b63	8a 82 cc fe 		mov	al,BYTE PTR [bp-308][si]
	*** 000b67	2a e4 			sub	ah,ah
	*** 000b69	50 			push	ax
	*** 000b6a	68 00 00 		push	OFFSET DGROUP:$SG856
	*** 000b6d	e8 00 00 		call	_printf
	*** 000b70	83 c4 04 		add	sp,4
;|*** 			}
;|*** 
;|***             if( bSerialDownload )
; Line 1101
					$I855:
	*** 000b73	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 000b78	74 0e 			je	$I857
;|***             {
;|***                 OEMWriteDebugByte(BootPacket[usIndex]);
; Line 1103
	*** 000b7a	8b 76 ce 		mov	si,WORD PTR [bp-50]	;usIndex
	*** 000b7d	8a 82 cc fe 		mov	al,BYTE PTR [bp-308][si]
	*** 000b81	50 			push	ax
	*** 000b82	e8 00 00 		call	_OEMWriteDebugByte
	*** 000b85	eb 0c 			jmp	SHORT $L1012
	*** 000b87	90 			nop	
					$I857:
;|***             }
;|***             else
;|***             {
;|***                 OEMParallelPortSendByte(BootPacket[usIndex]);
; Line 1107
	*** 000b88	8b 76 ce 		mov	si,WORD PTR [bp-50]	;usIndex
	*** 000b8b	8a 82 cc fe 		mov	al,BYTE PTR [bp-308][si]
	*** 000b8f	50 			push	ax
	*** 000b90	e8 00 00 		call	_OEMParallelPortSendByte
					$L1012:
	*** 000b93	83 c4 02 		add	sp,2
;|***             }
;|***             usIndex++;
; Line 1109
	*** 000b96	ff 46 ce 		inc	WORD PTR [bp-50]	;usIndex
;|***         }
; Line 1110
					$L1013:
	*** 000b99	8b 76 ce 		mov	si,WORD PTR [bp-50]	;usIndex
	*** 000b9c	8d 82 cc fe 		lea	ax,WORD PTR [bp-308][si]
	*** 000ba0	3b 86 ca fe 		cmp	ax,WORD PTR [bp-310]	;pDestByte
	*** 000ba4	72 9c 			jb	$FC852
;|*** 
;|***         if( bVerbose ) printf("Sent.\r\n");
; Line 1112
	*** 000ba6	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;bVerbose
	*** 000baa	75 03 			jne	$JCC2986
	*** 000bac	e9 ae 00 		jmp	$I867
					$JCC2986:
	*** 000baf	68 00 00 		push	OFFSET DGROUP:$SG860
	*** 000bb2	e8 00 00 		call	_printf
	*** 000bb5	e9 a2 00 		jmp	$L1017
					$I818:
;|***     }
;|***     else
;|***     {
;|***         hImage = _open(pszFileName, _O_BINARY | _O_RDONLY);
;|*** 
;|***         if( hImage == -1 )
; Line 1118
	*** 000bb8	68 00 80 		push	-32768	;8000H
	*** 000bbb	ff 76 08 		push	WORD PTR [bp+8]	;pszFileName
	*** 000bbe	e8 00 00 		call	__open
	*** 000bc1	83 c4 04 		add	sp,4
	*** 000bc4	89 46 fe 		mov	WORD PTR [bp-2],ax	;hImage
	*** 000bc7	40 			inc	ax
	*** 000bc8	75 26 			jne	$I862
;|***         {
;|*** 			fprintf(stderr,cReturnStri);
; Line 1120
	*** 000bca	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000bce	50 			push	ax
	*** 000bcf	68 10 00 		push	OFFSET __iob+16
	*** 000bd2	e8 00 00 		call	_fprintf
	*** 000bd5	83 c4 04 		add	sp,4
;|***             printf("%s: Error opening file - %s\n", pszFileName, _strerror(NULL));
; Line 1121
	*** 000bd8	6a 00 			push	0
	*** 000bda	e8 00 00 		call	__strerror
	*** 000bdd	83 c4 02 		add	sp,2
	*** 000be0	50 			push	ax
	*** 000be1	ff 76 08 		push	WORD PTR [bp+8]	;pszFileName
	*** 000be4	68 00 00 		push	OFFSET DGROUP:$SG863
	*** 000be7	e8 00 00 		call	_printf
	*** 000bea	83 c4 06 		add	sp,6
	*** 000bed	e9 6d fb 		jmp	$I790
;|***             return FALSE;
;|***         }
;|*** 
;|***         if( (lImageSize = _filelength(hImage)) == -1 )
; Line 1125
					$I862:
	*** 000bf0	ff 76 fe 		push	WORD PTR [bp-2]	;hImage
	*** 000bf3	e8 00 00 		call	__filelength
	*** 000bf6	83 c4 02 		add	sp,2
	*** 000bf9	89 46 fa 		mov	WORD PTR [bp-6],ax	;lImageSize
	*** 000bfc	89 56 fc 		mov	WORD PTR [bp-4],dx
	*** 000bff	3d ff ff 		cmp	ax,-1	;ffffH
	*** 000c02	75 2a 			jne	$I864
	*** 000c04	3b d0 			cmp	dx,ax
	*** 000c06	75 26 			jne	$I864
;|***         {
;|*** 			fprintf(stderr,cReturnStri);
; Line 1127
	*** 000c08	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000c0c	50 			push	ax
	*** 000c0d	68 10 00 		push	OFFSET __iob+16
	*** 000c10	e8 00 00 		call	_fprintf
	*** 000c13	83 c4 04 		add	sp,4
;|***             printf("%s: Error obtaining file size - %s\n", pszFileName, _strerror(NULL));
; Line 1128
	*** 000c16	6a 00 			push	0
	*** 000c18	e8 00 00 		call	__strerror
	*** 000c1b	83 c4 02 		add	sp,2
	*** 000c1e	50 			push	ax
	*** 000c1f	ff 76 08 		push	WORD PTR [bp+8]	;pszFileName
	*** 000c22	68 00 00 		push	OFFSET DGROUP:$SG865
	*** 000c25	e8 00 00 		call	_printf
	*** 000c28	83 c4 06 		add	sp,6
	*** 000c2b	e9 19 fb 		jmp	$L1016
;|***             if( !bParallelDownload && !bSerialDownload )
;|***                 _close(hImage);
;|*** 
;|***             return FALSE;
;|***         }
;|*** 
;|***         if( bVerbose )
; Line 1135
					$I864:
	*** 000c2e	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;bVerbose
	*** 000c32	74 29 			je	$I867
;|***         {
;|*** 			fprintf(stderr,cReturnStri);
; Line 1137
	*** 000c34	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000c38	50 			push	ax
	*** 000c39	68 10 00 		push	OFFSET __iob+16
	*** 000c3c	e8 00 00 		call	_fprintf
	*** 000c3f	83 c4 04 		add	sp,4
;|***             printf("Loading %s, size = %ld\n", pszFileName, lImageSize);
; Line 1138
	*** 000c42	ff 76 fc 		push	WORD PTR [bp-4]
	*** 000c45	ff 76 fa 		push	WORD PTR [bp-6]	;lImageSize
	*** 000c48	ff 76 08 		push	WORD PTR [bp+8]	;pszFileName
	*** 000c4b	68 00 00 		push	OFFSET DGROUP:$SG868
	*** 000c4e	e8 00 00 		call	_printf
	*** 000c51	83 c4 08 		add	sp,8
;|*** 	        DisplayCEOSVersion( pszFileName );  // Extract Version Number from image if available
; Line 1139
	*** 000c54	ff 76 08 		push	WORD PTR [bp+8]	;pszFileName
	*** 000c57	e8 00 00 		call	DisplayCEOSVersion
					$L1017:
	*** 000c5a	83 c4 02 		add	sp,2
;|*** 	    }
;|***     }
; Line 1141
					$I867:
;|*** 
;|***     // Read initial signature and physical start and size
;|*** 
;|***     usReadSize = sizeof(ucSignature) + 2 * sizeof(ULONG);
;|*** 
;|***     if( DownloadRead( hImage, ucBuffer, usReadSize, bParallelDownload) != usReadSize )
; Line 1147
	*** 000c5d	ff 76 06 		push	WORD PTR [bp+6]	;bParallelDownload
	*** 000c60	b8 0f 00 		mov	ax,15	;000fH
	*** 000c63	89 46 da 		mov	WORD PTR [bp-38],ax	;usReadSize
	*** 000c66	50 			push	ax
	*** 000c67	68 00 00 		push	OFFSET DGROUP:$S775_?ucBuffer@?1??LoadImage@@9@9
	*** 000c6a	ff 76 fe 		push	WORD PTR [bp-2]	;hImage
	*** 000c6d	e8 1c fa 		call	DownloadRead
	*** 000c70	83 c4 08 		add	sp,8
	*** 000c73	3d 0f 00 		cmp	ax,15	;000fH
	*** 000c76	74 1e 			je	$I869
;|***     {
;|*** 		fprintf(stderr,cReturnStri);
; Line 1149
	*** 000c78	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000c7c	50 			push	ax
	*** 000c7d	68 10 00 		push	OFFSET __iob+16
	*** 000c80	e8 00 00 		call	_fprintf
	*** 000c83	83 c4 04 		add	sp,4
;|***         printf("Error reading signature - %s\n", _strerror(NULL));
; Line 1150
	*** 000c86	6a 00 			push	0
	*** 000c88	e8 00 00 		call	__strerror
	*** 000c8b	83 c4 02 		add	sp,2
	*** 000c8e	50 			push	ax
	*** 000c8f	68 00 00 		push	OFFSET DGROUP:$SG870
	*** 000c92	e9 ac fa 		jmp	$L1015
	*** 000c95	90 			nop	
;|***         if( !bParallelDownload && !bSerialDownload )
;|***             _close(hImage);
;|*** 
;|***         return FALSE;
;|***     }
;|*** 
;|***     if( memcmp(ucBuffer, ucSignature, sizeof(ucSignature)) != 0 )
; Line 1157
					$I869:
	*** 000c96	b8 00 00 		mov	ax,OFFSET DGROUP:$S775_?ucBuffer@?1??LoadImage@@9@9
	*** 000c99	ba 00 00 		mov	dx,OFFSET DGROUP:$S777_?ucSignature@?1??LoadImage@@9@9
	*** 000c9c	b9 07 00 		mov	cx,7
	*** 000c9f	8b fa 			mov	di,dx
	*** 000ca1	8b f0 			mov	si,ax
	*** 000ca3	1e 			push	ds
	*** 000ca4	07 			pop	es
	*** 000ca5	d1 e9 			shr	cx,1
	*** 000ca7	1b c0 			sbb	ax,ax
	*** 000ca9	3b c9 			cmp	cx,cx
	*** 000cab	f3 			repz
	*** 000cac	a7 			cmpsw
	*** 000cad	75 04 			jne	$L983
	*** 000caf	2b c8 			sub	cx,ax
	*** 000cb1	f3 			repz
	*** 000cb2	a6 			cmpsb
					$L983:
	*** 000cb3	74 49 			je	$I872
;|***     {
;|*** 		fprintf(stderr,cReturnStri);
; Line 1159
	*** 000cb5	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000cb9	50 			push	ax
	*** 000cba	68 10 00 		push	OFFSET __iob+16
	*** 000cbd	e8 00 00 		call	_fprintf
	*** 000cc0	83 c4 04 		add	sp,4
;|***         printf("Error invalid signature\nData: ");
; Line 1160
	*** 000cc3	68 00 00 		push	OFFSET DGROUP:$SG873
	*** 000cc6	e8 00 00 		call	_printf
	*** 000cc9	83 c4 02 		add	sp,2
;|***         for( i = 0; i < (int)usReadSize; i++ )
; Line 1161
	*** 000ccc	c7 46 cc 00 00 		mov	WORD PTR [bp-52],0	;i
	*** 000cd1	eb 17 			jmp	SHORT $F874
	*** 000cd3	90 			nop	
					$FC875:
;|***             printf("%x ",ucBuffer[i]);
; Line 1162
	*** 000cd4	8b 5e cc 		mov	bx,WORD PTR [bp-52]	;i
	*** 000cd7	2a e4 			sub	ah,ah
	*** 000cd9	8a 87 00 00 		mov	al,BYTE PTR $S775_?ucBuffer@?1??LoadImage@@9@9[bx]
	*** 000cdd	50 			push	ax
	*** 000cde	68 00 00 		push	OFFSET DGROUP:$SG877
	*** 000ce1	e8 00 00 		call	_printf
	*** 000ce4	83 c4 04 		add	sp,4
	*** 000ce7	ff 46 cc 		inc	WORD PTR [bp-52]	;i
					$F874:
	*** 000cea	8b 46 da 		mov	ax,WORD PTR [bp-38]	;usReadSize
	*** 000ced	39 46 cc 		cmp	WORD PTR [bp-52],ax	;i
	*** 000cf0	7c e2 			jl	$FC875
;|***         printf("\r\n");
; Line 1163
	*** 000cf2	68 00 00 		push	OFFSET DGROUP:$SG878
	*** 000cf5	e8 00 00 		call	_printf
	*** 000cf8	83 c4 02 		add	sp,2
	*** 000cfb	e9 49 fa 		jmp	$L1016
;|***         if( !bParallelDownload && !bSerialDownload )
;|***             _close(hImage);
;|*** 
;|***         return FALSE;
;|***     }
;|*** 
;|***     ulReadTotal=*(PULONG)&ucBuffer[sizeof(ucSignature) + sizeof(ULONG)];
; Line 1170
					$I872:
	*** 000cfe	a1 0b 00 		mov	ax,WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+11
	*** 000d01	8b 16 0d 00 		mov	dx,WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+13
	*** 000d05	89 46 d4 		mov	WORD PTR [bp-44],ax	;ulReadTotal
	*** 000d08	89 56 d6 		mov	WORD PTR [bp-42],dx
;|*** 
;|***     // Print Physical start and size
;|*** 
;|***     if( bVerbose )
; Line 1174
	*** 000d0b	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;bVerbose
	*** 000d0f	74 27 			je	$I880
;|***     {
;|*** 		fprintf(stderr,cReturnStri);
; Line 1176
	*** 000d11	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000d15	50 			push	ax
	*** 000d16	68 10 00 		push	OFFSET __iob+16
	*** 000d19	e8 00 00 		call	_fprintf
	*** 000d1c	83 c4 04 		add	sp,4
;|***         printf( "Image physical start = 0x%8.8lX, size = %ld\n",
;|***               *(PULONG)&ucBuffer[sizeof(ucSignature)],
;|***               *(PULONG)&ucBuffer[sizeof(ucSignature) + sizeof(ULONG)]);
; Line 1179
	*** 000d1f	ff 36 0d 00 		push	WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+13
	*** 000d23	ff 36 0b 00 		push	WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+11
	*** 000d27	ff 36 09 00 		push	WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+9
	*** 000d2b	ff 36 07 00 		push	WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+7
	*** 000d2f	68 00 00 		push	OFFSET DGROUP:$SG881
	*** 000d32	e8 00 00 		call	_printf
	*** 000d35	83 c4 0a 		add	sp,10	;000aH
;|***     }
;|*** 
;|***     // Initialize the percent thingie.
;|*** 
;|***     DrawPercent( (DWORD)-1, (DWORD)"");
; Line 1184
					$I880:
	*** 000d38	1e 			push	ds
	*** 000d39	68 00 00 		push	OFFSET DGROUP:$SG882
	*** 000d3c	6a ff 			push	-1	;ffffH
	*** 000d3e	6a ff 			push	-1	;ffffH
	*** 000d40	e8 00 00 		call	_DrawPercent
	*** 000d43	83 c4 08 		add	sp,8
;|*** 
;|***     // Copy file to upper memory in CHUNKSIZE chunks
;|*** 
;|***     for(;;)
; Line 1188
					$FC884:
;|***     {
;|***         usAmountRead = DownloadRead(hImage, ucBuffer, 3 * sizeof(ULONG), bParallelDownload);
;|***         ulReadProgress+=12;
; Line 1191
	*** 000d46	83 46 d0 0c 		add	WORD PTR [bp-48],12	;000cH	;ulReadProgress
	*** 000d4a	83 56 d2 00 		adc	WORD PTR [bp-46],0
;|*** 
;|***         if( usAmountRead != 3 * sizeof(ULONG) )
; Line 1193
	*** 000d4e	ff 76 06 		push	WORD PTR [bp+6]	;bParallelDownload
	*** 000d51	6a 0c 			push	12	;000cH
	*** 000d53	68 00 00 		push	OFFSET DGROUP:$S775_?ucBuffer@?1??LoadImage@@9@9
	*** 000d56	ff 76 fe 		push	WORD PTR [bp-2]	;hImage
	*** 000d59	e8 30 f9 		call	DownloadRead
	*** 000d5c	83 c4 08 		add	sp,8
	*** 000d5f	89 46 d8 		mov	WORD PTR [bp-40],ax	;usAmountRead
	*** 000d62	3d 0c 00 		cmp	ax,12	;000cH
	*** 000d65	74 1f 			je	$I886
;|***         {
;|***             fprintf(stderr,cReturnStri);
; Line 1195
	*** 000d67	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000d6b	50 			push	ax
	*** 000d6c	68 10 00 		push	OFFSET __iob+16
	*** 000d6f	e8 00 00 		call	_fprintf
	*** 000d72	83 c4 04 		add	sp,4
;|***             printf("Error reading header - %s\n", XmsErrorString(xmsError));
; Line 1196
	*** 000d75	ff 76 f8 		push	WORD PTR [bp-8]	;xmsError
	*** 000d78	e8 00 00 		call	_XmsErrorString
	*** 000d7b	83 c4 02 		add	sp,2
	*** 000d7e	50 			push	ax
	*** 000d7f	68 00 00 		push	OFFSET DGROUP:$SG887
	*** 000d82	e9 bc f9 		jmp	$L1015
	*** 000d85	90 			nop	
;|***             if( !bParallelDownload && !bSerialDownload )
;|***                 _close(hImage);
;|*** 
;|***             return FALSE;
;|***         }
;|*** 
;|***         ulSectionAddress = *(PULONG)&ucBuffer[0];
; Line 1203
					$I886:
	*** 000d86	a1 00 00 		mov	ax,WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9
	*** 000d89	8b 16 02 00 		mov	dx,WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+2
	*** 000d8d	89 46 ec 		mov	WORD PTR [bp-20],ax	;ulSectionAddress
	*** 000d90	89 56 ee 		mov	WORD PTR [bp-18],dx
;|***         ulSectionSize = *(PULONG)&ucBuffer[4];
; Line 1204
	*** 000d93	8b 0e 04 00 		mov	cx,WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+4
	*** 000d97	8b 1e 06 00 		mov	bx,WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+6
	*** 000d9b	89 4e e8 		mov	WORD PTR [bp-24],cx	;ulSectionSize
	*** 000d9e	89 5e ea 		mov	WORD PTR [bp-22],bx
;|***         ulSectionChecksum = *(PULONG)&ucBuffer[8];
; Line 1205
	*** 000da1	8b 36 08 00 		mov	si,WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+8
	*** 000da5	8b 3e 0a 00 		mov	di,WORD PTR $S775_?ucBuffer@?1??LoadImage@@9@9+10
	*** 000da9	89 76 e4 		mov	WORD PTR [bp-28],si	;ulSectionChecksum
	*** 000dac	89 7e e6 		mov	WORD PTR [bp-26],di
;|*** 
;|***         if( ulSectionAddress == 0 )
; Line 1207
	*** 000daf	0b d0 			or	dx,ax
	*** 000db1	75 0b 			jne	$I889
;|***         {
;|***             *pulEntryPoint = ulSectionSize;
; Line 1209
	*** 000db3	8b 76 0a 		mov	si,WORD PTR [bp+10]	;pulEntryPoint
	*** 000db6	89 0c 			mov	WORD PTR [si],cx
	*** 000db8	89 5c 02 		mov	WORD PTR [si+2],bx
;|*** 
;|***             break;
; Line 1211
	*** 000dbb	e9 a8 01 		jmp	$FB885
;|***         }
;|*** 
;|***         if( ulSectionAddress < ulLinearAddress ||
; Line 1214
					$I889:
;|***             (ulSectionAddress + ulSectionSize) >
;|***             (ulLinearAddress + (ULONG)usLargestBlock * 1024) )
; Line 1216
	*** 000dbe	8b 46 f0 		mov	ax,WORD PTR [bp-16]	;ulLinearAddress
	*** 000dc1	8b 56 f2 		mov	dx,WORD PTR [bp-14]
	*** 000dc4	39 56 ee 		cmp	WORD PTR [bp-18],dx
	*** 000dc7	72 36 			jb	$L986
	*** 000dc9	77 05 			ja	$L984
	*** 000dcb	39 46 ec 		cmp	WORD PTR [bp-20],ax	;ulSectionAddress
	*** 000dce	72 2f 			jb	$L986
					$L984:
	*** 000dd0	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;usLargestBlock
	*** 000dd3	2b d2 			sub	dx,dx
	*** 000dd5	8a d4 			mov	dl,ah
	*** 000dd7	8a e0 			mov	ah,al
	*** 000dd9	2a c0 			sub	al,al
	*** 000ddb	03 c0 			add	ax,ax
	*** 000ddd	13 d2 			adc	dx,dx
	*** 000ddf	03 c0 			add	ax,ax
	*** 000de1	13 d2 			adc	dx,dx
	*** 000de3	03 46 f0 		add	ax,WORD PTR [bp-16]	;ulLinearAddress
	*** 000de6	13 56 f2 		adc	dx,WORD PTR [bp-14]
	*** 000de9	8b 4e e8 		mov	cx,WORD PTR [bp-24]	;ulSectionSize
	*** 000dec	8b 5e ea 		mov	bx,WORD PTR [bp-22]
	*** 000def	03 4e ec 		add	cx,WORD PTR [bp-20]	;ulSectionAddress
	*** 000df2	13 5e ee 		adc	bx,WORD PTR [bp-18]
	*** 000df5	3b d3 			cmp	dx,bx
	*** 000df7	77 47 			ja	$I890
	*** 000df9	72 04 			jb	$L986
	*** 000dfb	3b c1 			cmp	ax,cx
	*** 000dfd	73 41 			jae	$I890
					$L986:
;|***         {
;|***             fprintf(stderr,cReturnStri);
; Line 1218
	*** 000dff	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000e03	50 			push	ax
	*** 000e04	68 10 00 		push	OFFSET __iob+16
	*** 000e07	e8 00 00 		call	_fprintf
	*** 000e0a	83 c4 04 		add	sp,4
;|***             printf(
;|***                   "Error image section doesn't fit in allocated block\n"
;|***                   "      Block allocated at 0x%lX, size = %ld\n"
;|***                   "      Section physical start = 0x%8.8lX, size = %ld\n"
;|*** 				  "      Memory too low in your VM might cause this.\n"
;|*** 				  "\n"
;|*** 				  "        >> Increase memory may fix this.\n",
;|***                   ulLinearAddress, (ULONG)usLargestBlock * 1024,
;|***                   ulSectionAddress, ulSectionSize);
; Line 1227
	*** 000e0d	ff 76 ea 		push	WORD PTR [bp-22]
	*** 000e10	ff 76 e8 		push	WORD PTR [bp-24]	;ulSectionSize
	*** 000e13	ff 76 ee 		push	WORD PTR [bp-18]
	*** 000e16	ff 76 ec 		push	WORD PTR [bp-20]	;ulSectionAddress
	*** 000e19	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;usLargestBlock
	*** 000e1c	2b d2 			sub	dx,dx
	*** 000e1e	8a d4 			mov	dl,ah
	*** 000e20	8a e0 			mov	ah,al
	*** 000e22	2a c0 			sub	al,al
	*** 000e24	03 c0 			add	ax,ax
	*** 000e26	13 d2 			adc	dx,dx
	*** 000e28	03 c0 			add	ax,ax
	*** 000e2a	13 d2 			adc	dx,dx
	*** 000e2c	52 			push	dx
	*** 000e2d	50 			push	ax
	*** 000e2e	ff 76 f2 		push	WORD PTR [bp-14]
	*** 000e31	ff 76 f0 		push	WORD PTR [bp-16]	;ulLinearAddress
	*** 000e34	68 00 00 		push	OFFSET DGROUP:$SG892
	*** 000e37	e8 00 00 		call	_printf
	*** 000e3a	83 c4 12 		add	sp,18	;0012H
	*** 000e3d	e9 07 f9 		jmp	$L1016
;|*** 
;|***             if( !bParallelDownload && !bSerialDownload )
;|***                 _close(hImage);
;|*** 
;|***             return FALSE;
;|***         }
;|*** 
;|***         if( bVerbose )
; Line 1235
					$I890:
	*** 000e40	83 7e 04 00 		cmp	WORD PTR [bp+4],0	;bVerbose
	*** 000e44	74 23 			je	$I894
;|***         {
;|***             fprintf(stderr,cReturnStri);
; Line 1237
	*** 000e46	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000e4a	50 			push	ax
	*** 000e4b	68 10 00 		push	OFFSET __iob+16
	*** 000e4e	e8 00 00 		call	_fprintf
	*** 000e51	83 c4 04 		add	sp,4
;|***             printf(
;|***                   "Section physical start = 0x%8.8lX, size = %ld\n",
;|***                   ulSectionAddress, ulSectionSize);
; Line 1240
	*** 000e54	ff 76 ea 		push	WORD PTR [bp-22]
	*** 000e57	ff 76 e8 		push	WORD PTR [bp-24]	;ulSectionSize
	*** 000e5a	ff 76 ee 		push	WORD PTR [bp-18]
	*** 000e5d	ff 76 ec 		push	WORD PTR [bp-20]	;ulSectionAddress
	*** 000e60	68 00 00 		push	OFFSET DGROUP:$SG895
	*** 000e63	e8 00 00 		call	_printf
	*** 000e66	83 c4 0a 		add	sp,10	;000aH
;|***         }
;|*** 
;|***         ulChecksum = 0;
; Line 1243
					$I894:
	*** 000e69	2b c0 			sub	ax,ax
	*** 000e6b	89 46 de 		mov	WORD PTR [bp-34],ax
	*** 000e6e	89 46 dc 		mov	WORD PTR [bp-36],ax	;ulChecksum
;|*** 
;|***         for( ulSectionOffset = 0; ulSectionOffset < ulSectionSize; )
; Line 1245
	*** 000e71	89 46 e2 		mov	WORD PTR [bp-30],ax
	*** 000e74	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulSectionOffset
					$FC897:
	*** 000e77	8b 46 e8 		mov	ax,WORD PTR [bp-24]	;ulSectionSize
	*** 000e7a	8b 56 ea 		mov	dx,WORD PTR [bp-22]
	*** 000e7d	39 56 e2 		cmp	WORD PTR [bp-30],dx
	*** 000e80	76 03 			jbe	$JCC3712
	*** 000e82	e9 c1 fe 		jmp	$FC884
					$JCC3712:
	*** 000e85	72 08 			jb	$L987
	*** 000e87	39 46 e0 		cmp	WORD PTR [bp-32],ax	;ulSectionOffset
	*** 000e8a	72 03 			jb	$JCC3722
	*** 000e8c	e9 b7 fe 		jmp	$FC884
					$JCC3722:
					$L987:
;|***         {
;|***             if( (ulSectionSize - ulSectionOffset) < CHUNKSIZE )
; Line 1247
	*** 000e8f	2b 46 e0 		sub	ax,WORD PTR [bp-32]	;ulSectionOffset
	*** 000e92	1b 56 e2 		sbb	dx,WORD PTR [bp-30]
	*** 000e95	0b d2 			or	dx,dx
	*** 000e97	75 11 			jne	$I899
	*** 000e99	3d 00 80 		cmp	ax,-32768	;8000H
	*** 000e9c	73 0c 			jae	$I899
;|***             {
;|***                 usReadSize = (USHORT)(ulSectionSize - ulSectionOffset);
; Line 1249
	*** 000e9e	8b 46 e8 		mov	ax,WORD PTR [bp-24]	;ulSectionSize
	*** 000ea1	2b 46 e0 		sub	ax,WORD PTR [bp-32]	;ulSectionOffset
	*** 000ea4	89 46 da 		mov	WORD PTR [bp-38],ax	;usReadSize
;|***             }
;|***             else
; Line 1251
	*** 000ea7	eb 06 			jmp	SHORT $I900
	*** 000ea9	90 			nop	
					$I899:
;|***             {
;|***                 usReadSize = CHUNKSIZE;
; Line 1253
	*** 000eaa	c7 46 da 00 80 		mov	WORD PTR [bp-38],-32768	;8000H	;usReadSize
;|***             }
; Line 1254
					$I900:
;|***             usAmountRead = DownloadRead(hImage, ucBuffer, usReadSize,bParallelDownload);
;|*** 
;|***             if( usAmountRead != usReadSize )
; Line 1257
	*** 000eaf	ff 76 06 		push	WORD PTR [bp+6]	;bParallelDownload
	*** 000eb2	ff 76 da 		push	WORD PTR [bp-38]	;usReadSize
	*** 000eb5	68 00 00 		push	OFFSET DGROUP:$S775_?ucBuffer@?1??LoadImage@@9@9
	*** 000eb8	ff 76 fe 		push	WORD PTR [bp-2]	;hImage
	*** 000ebb	e8 ce f7 		call	DownloadRead
	*** 000ebe	83 c4 08 		add	sp,8
	*** 000ec1	89 46 d8 		mov	WORD PTR [bp-40],ax	;usAmountRead
	*** 000ec4	3b 46 da 		cmp	ax,WORD PTR [bp-38]	;usReadSize
	*** 000ec7	74 1f 			je	$I901
;|***             {
;|***                 fprintf(stderr,cReturnStri);
; Line 1259
	*** 000ec9	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000ecd	50 			push	ax
	*** 000ece	68 10 00 		push	OFFSET __iob+16
	*** 000ed1	e8 00 00 		call	_fprintf
	*** 000ed4	83 c4 04 		add	sp,4
;|***                 printf("Error reading section - %s\n", XmsErrorString(xmsError));
; Line 1260
	*** 000ed7	ff 76 f8 		push	WORD PTR [bp-8]	;xmsError
	*** 000eda	e8 00 00 		call	_XmsErrorString
	*** 000edd	83 c4 02 		add	sp,2
	*** 000ee0	50 			push	ax
	*** 000ee1	68 00 00 		push	OFFSET DGROUP:$SG902
	*** 000ee4	e9 5a f8 		jmp	$L1015
	*** 000ee7	90 			nop	
;|***                 if( !bParallelDownload && !bSerialDownload )
;|***                     _close(hImage);
;|*** 
;|***                 return FALSE;
;|***             }
;|***             ulReadProgress+= usReadSize;
; Line 1266
					$I901:
;|***             DrawPercent(ulReadProgress, ulReadTotal);
; Line 1267
	*** 000ee8	ff 76 d6 		push	WORD PTR [bp-42]
	*** 000eeb	ff 76 d4 		push	WORD PTR [bp-44]	;ulReadTotal
	*** 000eee	8b 46 da 		mov	ax,WORD PTR [bp-38]	;usReadSize
	*** 000ef1	2b d2 			sub	dx,dx
	*** 000ef3	01 46 d0 		add	WORD PTR [bp-48],ax	;ulReadProgress
	*** 000ef6	11 56 d2 		adc	WORD PTR [bp-46],dx
	*** 000ef9	ff 76 d2 		push	WORD PTR [bp-46]
	*** 000efc	ff 76 d0 		push	WORD PTR [bp-48]	;ulReadProgress
	*** 000eff	e8 00 00 		call	_DrawPercent
	*** 000f02	83 c4 08 		add	sp,8
;|*** 
;|*** #if 0
;|***             for( usIndex = 0; usIndex < usAmountRead; usIndex++ )
;|***             {
;|***                 ulChecksum += ucBuffer[usIndex];
;|***             }
;|*** #endif
;|*** 
;|*** #if 1
;|***             xmsError = XmsMoveExtendedMemory(
;|***                                             0, (ULONG)(UCHAR far *)ucBuffer,
;|***                                             usBlockHandle, ulSectionAddress - ulLinearAddress + ulSectionOffset,
;|***                                             (usAmountRead + 1) & ~1U);
;|*** 
;|***             if( xmsError != XMS_SUCCESS )
; Line 1282
	*** 000f05	8b 46 d8 		mov	ax,WORD PTR [bp-40]	;usAmountRead
	*** 000f08	40 			inc	ax
	*** 000f09	24 fe 			and	al,254	;00feH
	*** 000f0b	6a 00 			push	0
	*** 000f0d	50 			push	ax
	*** 000f0e	8b 46 e0 		mov	ax,WORD PTR [bp-32]	;ulSectionOffset
	*** 000f11	8b 56 e2 		mov	dx,WORD PTR [bp-30]
	*** 000f14	2b 46 f0 		sub	ax,WORD PTR [bp-16]	;ulLinearAddress
	*** 000f17	1b 56 f2 		sbb	dx,WORD PTR [bp-14]
	*** 000f1a	03 46 ec 		add	ax,WORD PTR [bp-20]	;ulSectionAddress
	*** 000f1d	13 56 ee 		adc	dx,WORD PTR [bp-18]
	*** 000f20	52 			push	dx
	*** 000f21	50 			push	ax
	*** 000f22	ff 36 00 00 		push	WORD PTR _usBlockHandle
	*** 000f26	1e 			push	ds
	*** 000f27	68 00 00 		push	OFFSET DGROUP:$S775_?ucBuffer@?1??LoadImage@@9@9
	*** 000f2a	6a 00 			push	0
	*** 000f2c	e8 00 00 		call	_XmsMoveExtendedMemory
	*** 000f2f	83 c4 10 		add	sp,16	;0010H
	*** 000f32	89 46 f8 		mov	WORD PTR [bp-8],ax	;xmsError
	*** 000f35	0b c0 			or	ax,ax
	*** 000f37	74 1f 			je	$I904
;|***             {
;|***                 fprintf(stderr,cReturnStri);
; Line 1284
	*** 000f39	8d 8e 80 fe 		lea	cx,WORD PTR [bp-384]	;cReturnStri
	*** 000f3d	51 			push	cx
	*** 000f3e	68 10 00 		push	OFFSET __iob+16
	*** 000f41	e8 00 00 		call	_fprintf
	*** 000f44	83 c4 04 		add	sp,4
;|***                 printf("Error moving extended memory - %s\n", XmsErrorString(xmsError));
; Line 1285
	*** 000f47	ff 76 f8 		push	WORD PTR [bp-8]	;xmsError
	*** 000f4a	e8 00 00 		call	_XmsErrorString
	*** 000f4d	83 c4 02 		add	sp,2
	*** 000f50	50 			push	ax
	*** 000f51	68 00 00 		push	OFFSET DGROUP:$SG905
	*** 000f54	e9 ea f7 		jmp	$L1015
	*** 000f57	90 			nop	
;|***                 if( !bParallelDownload && !bSerialDownload )
;|***                     _close(hImage);
;|*** 
;|***                 return FALSE;
;|***             }
;|*** #endif
;|***             ulSectionOffset += usAmountRead;
; Line 1292
					$I904:
	*** 000f58	8b 46 d8 		mov	ax,WORD PTR [bp-40]	;usAmountRead
	*** 000f5b	2b d2 			sub	dx,dx
	*** 000f5d	01 46 e0 		add	WORD PTR [bp-32],ax	;ulSectionOffset
	*** 000f60	11 56 e2 		adc	WORD PTR [bp-30],dx
;|***         }
; Line 1293
	*** 000f63	e9 11 ff 		jmp	$FC897
					$FB885:
;|*** #if 0
;|***         if( ulChecksum != ulSectionChecksum )
;|***         {
;|***             fprintf(stderr,cReturnStri);
;|***             printf(
;|***                   "Bad checksum 0x%8.8lX, expected 0x%8.8lX\n",
;|***                   ulChecksum, ulSectionChecksum);
;|*** 
;|***             if( !bParallelDownload && !bSerialDownload )
;|***                 _close(hImage);
;|*** 
;|***             return FALSE;
;|***         }
;|*** #endif
;|***     }
;|*** 
;|***     DrawPercent(ulReadTotal, ulReadTotal);
; Line 1310
	*** 000f66	ff 76 d6 		push	WORD PTR [bp-42]
	*** 000f69	ff 76 d4 		push	WORD PTR [bp-44]	;ulReadTotal
	*** 000f6c	ff 76 d6 		push	WORD PTR [bp-42]
	*** 000f6f	ff 76 d4 		push	WORD PTR [bp-44]	;ulReadTotal
	*** 000f72	e8 00 00 		call	_DrawPercent
	*** 000f75	83 c4 08 		add	sp,8
;|*** 
;|***     if( !bParallelDownload && !bSerialDownload )
; Line 1312
	*** 000f78	83 7e 06 00 		cmp	WORD PTR [bp+6],0	;bParallelDownload
	*** 000f7c	75 10 			jne	$I907
	*** 000f7e	83 3e 00 00 00 		cmp	WORD PTR _bSerialDownload,0
	*** 000f83	75 09 			jne	$I907
;|***     {
;|***         _close(hImage);
; Line 1314
	*** 000f85	ff 76 fe 		push	WORD PTR [bp-2]	;hImage
	*** 000f88	e8 00 00 		call	__close
	*** 000f8b	83 c4 02 		add	sp,2
;|***     }
;|*** 
;|***     // Stop the floppy motor in case it contained the image file
;|*** 
;|***     __asm
; Line 1319
					$I907:
;|***     {
;|***         push    dx
; Line 1321
	*** 000f8e	52 			push	dx
;|***         mov     dx, 03F2h   ; Floppy motor and DMA control
; Line 1322
	*** 000f8f	ba f2 03 		mov	dx,1010	;03f2H
;|***         in      al, dx
; Line 1323
	*** 000f92	ec 			in	al,dx
;|***         and     al, 00Fh    ; Clear motor on bits
; Line 1324
	*** 000f93	24 0f 			and	al,15	;000fH
;|***         out     dx, al
; Line 1325
	*** 000f95	ee 			out	dx, al

;|***         pop     dx
; Line 1326
	*** 000f96	5a 			pop	dx
;|***     }
; Line 1327
;|***     fprintf(stderr,cReturnStri);
; Line 1328
	*** 000f97	8d 86 80 fe 		lea	ax,WORD PTR [bp-384]	;cReturnStri
	*** 000f9b	50 			push	ax
	*** 000f9c	68 10 00 		push	OFFSET __iob+16
	*** 000f9f	e8 00 00 		call	_fprintf
	*** 000fa2	83 c4 04 		add	sp,4
;|*** 
;|***     // Indicate success
;|*** 
;|***     return( TRUE );
; Line 1332
	*** 000fa5	b8 01 00 		mov	ax,1
;|*** }
; Line 1333
	*** 000fa8	5e 			pop	si
	*** 000fa9	5f 			pop	di
	*** 000faa	c9 			leave	
	*** 000fab	c3 			ret	

LoadImage	ENDP

GetPCIConfigMechanism	PROC NEAR
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Function Name:  GetPCIConfigMechanism()
;|*** //  Description..:  Execute trap to obtain PCI configuration Mechanism.
;|*** //  Inputs.......:  none
;|*** //  Outputs......:  UCHAR  0 indicates no PCI bus, else PCI configuration mech.
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** static UCHAR GetPCIConfigMechanism()
;|*** {
; Line 1345
	*** 000fac	c8 08 00 00 		enter	8,0
;	ucPCIVersionMajor = -2
;	ucPCIVersionMinor = -4
;	ucPCIBus = -6
;	ucPCIConfigMech = -8
;|***     UCHAR   ucPCIVersionMajor;
;|***     UCHAR   ucPCIVersionMinor;
;|***     UCHAR   ucPCIBus;
;|***     UCHAR   ucPCIConfigMech;
;|*** 
;|***     __asm
;|***     {
;|***         mov     ax, 0xB101
; Line 1353
	*** 000fb0	b8 01 b1 		mov	ax,-20223	;b101H
;|***         int     0x1A
; Line 1354
	*** 000fb3	cd 1a 			int	26	;001aH
;|*** 
;|***         jc      noPCI
; Line 1356
	*** 000fb5	72 23 			jb	$noPCI913
;|*** 
;|***         cmp     dx, 0x4350     ; 'CP'
; Line 1358
	*** 000fb7	81 fa 50 43 		cmp	dx,17232	;4350H
;|*** 
;|***         jne     noPCI
; Line 1360
	*** 000fbb	75 1d 			jne	$noPCI913
;|*** 
;|***         or      ah, ah
; Line 1362
	*** 000fbd	0a e4 			or	ah,ah
;|***         jnz     noPCI
; Line 1363
	*** 000fbf	75 19 			jne	$noPCI913
;|*** 
;|***         mov     ucPCIVersionMajor, bh
; Line 1365
	*** 000fc1	88 7e fe 		mov	BYTE PTR [bp-2],bh	;ucPCIVersionMajor
;|***         mov     ucPCIVersionMinor, bl
; Line 1366
	*** 000fc4	88 5e fc 		mov	BYTE PTR [bp-4],bl	;ucPCIVersionMinor
;|***         mov     ucPCIBus, cl
; Line 1367
	*** 000fc7	88 4e fa 		mov	BYTE PTR [bp-6],cl	;ucPCIBus
;|*** 
;|***         and     al, 0x03
; Line 1369
	*** 000fca	24 03 			and	al,3
;|***         mov     ucPCIConfigMech, al
; Line 1370
	*** 000fcc	88 46 f8 		mov	BYTE PTR [bp-8],al	;ucPCIConfigMech
;|***     }
; Line 1371
;|*** 
;|***     // Indicate PCI bus info
;|*** 
;|***     /*printf( "%d PCI bus%s (Version %X.%2.2X) using Configuration Mechanism # %d\n",
;|***         ucPCIBus + 1, ucPCIBus == 0 ? "" : "ses",
;|***         ucPCIVersionMajor, ucPCIVersionMinor, ucPCIConfigMech);*/
;|*** 
;|*** 
;|***     // Indicate Configuration mechanism
;|*** 
;|***     return( UCHAR)((ucPCIBus << 2) | ucPCIConfigMech );
; Line 1382
	*** 000fcf	8a 46 fa 		mov	al,BYTE PTR [bp-6]	;ucPCIBus
	*** 000fd2	c0 e0 02 		shl	al,2
	*** 000fd5	0a 46 f8 		or	al,BYTE PTR [bp-8]	;ucPCIConfigMech
	*** 000fd8	c9 			leave	
	*** 000fd9	c3 			ret	
;|*** 
;|***     // Indicate no PCI bus
;|*** 
;|***     noPCI: printf( "PCI bus not detected\n" );
; Line 1386
					$noPCI913:
	*** 000fda	68 00 00 		push	OFFSET DGROUP:$SG914
	*** 000fdd	e8 00 00 		call	_printf
;|***     return( 0 );
; Line 1387
	*** 000fe0	32 c0 			xor	al,al
;|*** }
; Line 1388
	*** 000fe2	c9 			leave	
	*** 000fe3	c3 			ret	

GetPCIConfigMechanism	ENDP

GetJumpFlags	PROC NEAR
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Type Name..:    JUMP_PACKET    
;|*** //  Description:    Defines the JUMP_PACKET type. Type is byte aligned.
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** #pragma pack(1)
;|*** 
;|*** typedef struct JUMP_PACKET 
;|*** {
;|***     UCHAR   Header[BOOT_HEADER_SIZE];
;|***     WORD    wLen;
;|***     DWORD   dwTransport;
;|***     UCHAR   ucChkSum;
;|***     UCHAR   Tail[BOOT_TAIL_SIZE];
;|*** } 
;|*** JUMP_PACKET, *PJUMP_PACKET;
;|*** 
;|*** #pragma pack()
;|*** 
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Function Name:  GetJumpFlags(void)
;|*** //  Description..:  This function validates the JUMP_PACKET and if valid
;|*** //                  indicates the transport parameter.
;|*** //  Inputs.......:  none
;|*** //  Outputs......:  0 indicates JUMP_PACKET failure, else Transport parameter
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** static WORD GetJumpFlags(void)
;|*** {
; Line 1423
	*** 000fe4	c8 12 00 00 		enter	18,0
	*** 000fe8	57 			push	di
	*** 000fe9	56 			push	si
;	Packet = -18
;	usRead = -20
;	register si = pData
;	CheckSum = -1
;	i = -26
;|***     JUMP_PACKET Packet;
;|***     USHORT usRead;
;|***     UCHAR *pData;
;|***     UCHAR CheckSum;
;|***     int i;
;|*** 
;|***     usRead = DownloadRead( 0, (UCHAR *)&Packet, sizeof(Packet), TRUE );
;|*** 
;|***     // check read size
;|*** 
;|***     if( usRead != sizeof(Packet) )
; Line 1434
	*** 000fea	6a 01 			push	1
	*** 000fec	6a 11 			push	17	;0011H
	*** 000fee	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;Packet
	*** 000ff1	50 			push	ax
	*** 000ff2	6a 00 			push	0
	*** 000ff4	e8 95 f6 		call	DownloadRead
	*** 000ff7	83 c4 08 		add	sp,8
	*** 000ffa	3d 11 00 		cmp	ax,17	;0011H
	*** 000ffd	74 07 			je	$I924
;|***     {
;|***         printf( "Read Packet Failed\n" );
; Line 1436
	*** 000fff	68 00 00 		push	OFFSET DGROUP:$SG925
	*** 001002	e9 80 00 		jmp	$L1022
	*** 001005	90 			nop	
;|***         return 0;       // KTS_DEFAULT
;|***     }
;|*** 
;|***     // check header/tail valid
;|*** 
;|***     if( (memcmp(Packet.Header, BootHeader, 4) != 0) ||
; Line 1442
					$I924:
;|***         (memcmp(Packet.Tail,   BootTail,   4) != 0) )
; Line 1443
	*** 001006	b8 00 00 		mov	ax,OFFSET DGROUP:$S519_BootHeader
	*** 001009	b9 04 00 		mov	cx,4
	*** 00100c	8b f8 			mov	di,ax
	*** 00100e	8d 76 ee 		lea	si,WORD PTR [bp-18]	;Packet
	*** 001011	1e 			push	ds
	*** 001012	07 			pop	es
	*** 001013	d1 e9 			shr	cx,1
	*** 001015	1b c0 			sbb	ax,ax
	*** 001017	3b c9 			cmp	cx,cx
	*** 001019	f3 			repz
	*** 00101a	a7 			cmpsw
	*** 00101b	75 65 			jne	$I927
	*** 00101d	2b c8 			sub	cx,ax
	*** 00101f	f3 			repz
	*** 001020	a6 			cmpsb
	*** 001021	75 5f 			jne	$I927
	*** 001023	b8 00 00 		mov	ax,OFFSET DGROUP:$S520_BootTail
	*** 001026	b9 04 00 		mov	cx,4
	*** 001029	8b f8 			mov	di,ax
	*** 00102b	8d 76 fb 		lea	si,WORD PTR [bp-5]
	*** 00102e	d1 e9 			shr	cx,1
	*** 001030	1b c0 			sbb	ax,ax
	*** 001032	3b c9 			cmp	cx,cx
	*** 001034	f3 			repz
	*** 001035	a7 			cmpsw
	*** 001036	75 4a 			jne	$I927
	*** 001038	2b c8 			sub	cx,ax
	*** 00103a	f3 			repz
	*** 00103b	a6 			cmpsb
	*** 00103c	75 44 			jne	$I927
;|***     {
;|***         printf( "Read Header/Tail failed\n");
;|***         return 0;
;|***     }
;|*** 
;|***     // check command
;|*** 
;|***     if( Packet.Header[4] != 0x00 || Packet.Header[5] != 0x00 )
; Line 1451
	*** 00103e	80 7e f2 00 		cmp	BYTE PTR [bp-14],0
	*** 001042	75 38 			jne	$I930
	*** 001044	80 7e f3 00 		cmp	BYTE PTR [bp-13],0
	*** 001048	75 32 			jne	$I930
;|***     {
;|***         printf("Invalid Command\n");
;|***         return 0;
;|***     }
;|*** 
;|***     // check wlen
;|*** 
;|***     if( Packet.wLen != 9 )
; Line 1459
	*** 00104a	83 7e f4 09 		cmp	WORD PTR [bp-12],9
	*** 00104e	74 06 			je	$I932
;|***     {
;|***         printf("Invalid Length\n");
; Line 1461
	*** 001050	68 00 00 		push	OFFSET DGROUP:$SG933
	*** 001053	eb 30 			jmp	SHORT $L1022
	*** 001055	90 			nop	
;|***         return 0;
;|***     }
;|*** 
;|***     // check checksum
;|*** 
;|***     CheckSum = 0;
; Line 1467
					$I932:
	*** 001056	c6 46 ff 00 		mov	BYTE PTR [bp-1],0	;CheckSum
;|*** 
;|***     for( i=0, pData = (UCHAR *)&Packet.dwTransport; i < sizeof(Packet.dwTransport); i++, pData++ )
; Line 1469
	*** 00105a	8d 76 f6 		lea	si,WORD PTR [bp-10]
	*** 00105d	ba 04 00 		mov	dx,4
					$F934:
;|***     {
;|***         CheckSum += *pData;
; Line 1471
	*** 001060	ac 			lodsb
	*** 001061	00 46 ff 		add	BYTE PTR [bp-1],al	;CheckSum
	*** 001064	4a 			dec	dx
	*** 001065	75 f9 			jne	$F934
;|***     }
;|*** 
;|***     if( CheckSum != Packet.ucChkSum )
; Line 1474
	*** 001067	8a 46 fa 		mov	al,BYTE PTR [bp-6]
	*** 00106a	38 46 ff 		cmp	BYTE PTR [bp-1],al	;CheckSum
	*** 00106d	74 05 			je	$I937
;|***     {
;|***         printf("Invalid checksum\n");
; Line 1476
	*** 00106f	68 00 00 		push	OFFSET DGROUP:$SG938
	*** 001072	eb 11 			jmp	SHORT $L1022
;|***         return 0;
;|***     }
;|*** 
;|***     // Packet is valid - indicate Transport
;|*** 
;|***     return( (WORD)Packet.dwTransport );
; Line 1482
					$I937:
	*** 001074	8b 46 f6 		mov	ax,WORD PTR [bp-10]
	*** 001077	5e 			pop	si
	*** 001078	5f 			pop	di
	*** 001079	c9 			leave	
	*** 00107a	c3 			ret	
	*** 00107b	90 			nop	
;|***     if( Packet.Header[4] != 0x00 || Packet.Header[5] != 0x00 )
; Line 1451
					$I930:
;|***     {
;|***         printf("Invalid Command\n");
; Line 1453
	*** 00107c	68 00 00 		push	OFFSET DGROUP:$SG931
	*** 00107f	eb 04 			jmp	SHORT $L1022
	*** 001081	90 			nop	
;|***         (memcmp(Packet.Tail,   BootTail,   4) != 0) )
; Line 1443
					$I927:
;|***     {
;|***         printf( "Read Header/Tail failed\n");
; Line 1445
	*** 001082	68 00 00 		push	OFFSET DGROUP:$SG928
					$L1022:
	*** 001085	e8 00 00 		call	_printf
	*** 001088	83 c4 02 		add	sp,2
;|***         return 0;
; Line 1446
	*** 00108b	33 c0 			xor	ax,ax
;|***     }
;|*** 
;|***     // check command
;|*** 
;|***     if( Packet.Header[4] != 0x00 || Packet.Header[5] != 0x00 )
;|***     {
;|***         printf("Invalid Command\n");
;|***         return 0;
;|***     }
;|*** 
;|***     // check wlen
;|*** 
;|***     if( Packet.wLen != 9 )
;|***     {
;|***         printf("Invalid Length\n");
;|***         return 0;
;|***     }
;|*** 
;|***     // check checksum
;|*** 
;|***     CheckSum = 0;
;|*** 
;|***     for( i=0, pData = (UCHAR *)&Packet.dwTransport; i < sizeof(Packet.dwTransport); i++, pData++ )
;|***     {
;|***         CheckSum += *pData;
;|***     }
;|*** 
;|***     if( CheckSum != Packet.ucChkSum )
;|***     {
;|***         printf("Invalid checksum\n");
;|***         return 0;
;|***     }
;|*** 
;|***     // Packet is valid - indicate Transport
;|*** 
;|***     return( (WORD)Packet.dwTransport );
;|*** }
; Line 1483
	*** 00108d	5e 			pop	si
	*** 00108e	5f 			pop	di
	*** 00108f	c9 			leave	
	*** 001090	c3 			ret	
	*** 001091	90 			nop	

GetJumpFlags	ENDP

DisplayCEOSVersion	PROC NEAR
;|*** 
;|*** 
;|*** //------------------------------------------------------------------------------
;|*** //
;|*** //  Function Name:  DisplayCEOSVersion(void)
;|*** //  Description..:  This function searches through the Image binary (e.g. eboot.bin) looking for
;|*** //		    a Windows CE Version number, delimited by a unique string--> "$@( VER $@("
;|*** //  Inputs.......:  char *pszFileName, denotes the image being loaded by LoadImage
;|*** //  Outputs......:  none, simply prints debug info to the user
;|*** //
;|*** //------------------------------------------------------------------------------
;|*** 
;|*** static void DisplayCEOSVersion(char *pszFileName)
;|*** {
; Line 1497
	*** 001092	c8 10 00 00 		enter	16,0
	*** 001096	57 			push	di
	*** 001097	56 			push	si
;	pszFileName = 4
;	delim = -16
;	register si = delim_ptr
;	delim_end = -2
;	align32bit = -10
;	lImageFile = -4
;	ver_lo = -10
;	ver_hi = -12
;	done = -6
;	iterations = -8
;	cnt = -22
;|*** 
;|*** #define DELIM_LEN 3
;|*** 
;|***     char delim[] = "$@(";		// To change delimiter, modify delim & DELIM_LEN!
; Line 1501
	*** 001098	a1 00 00 		mov	ax,WORD PTR $SG943
	*** 00109b	8b 16 02 00 		mov	dx,WORD PTR $SG943+2
	*** 00109f	89 46 f0 		mov	WORD PTR [bp-16],ax	;delim
	*** 0010a2	89 56 f2 		mov	WORD PTR [bp-14],dx
;|***     char *delim_ptr = delim;
; Line 1502
	*** 0010a5	8d 76 f0 		lea	si,WORD PTR [bp-16]	;delim
;|***     char *delim_end = delim + DELIM_LEN;
; Line 1503
	*** 0010a8	8d 46 f3 		lea	ax,WORD PTR [bp-13]
	*** 0010ab	89 46 fe 		mov	WORD PTR [bp-2],ax	;delim_end
;|***     int  align32bit = 4 - ( DELIM_LEN % 4 );
;|*** 
;|***     FILE *lImageFile = NULL;	
;|***     int  ver_lo,ver_hi;			
;|***     int  done = 0;			// Loop exit condition, done = 1 denotes version found
;|***     int  iterations = 0;		// Used to limit search length
; Line 1509
	*** 0010ae	33 c0 			xor	ax,ax
	*** 0010b0	89 46 fa 		mov	WORD PTR [bp-6],ax	;done
	*** 0010b3	89 46 f8 		mov	WORD PTR [bp-8],ax	;iterations
;|***     int  cnt;					
;|*** 
;|***     lImageFile = fopen( pszFileName, "rb" );
;|*** 
;|***     // Algorithm to search through image for 'delim' (version) 'delim'
;|***     // If successful, sets done = 1.
;|***     if( lImageFile ) {
; Line 1516
	*** 0010b6	68 00 00 		push	OFFSET DGROUP:$SG953
	*** 0010b9	ff 76 04 		push	WORD PTR [bp+4]	;pszFileName
	*** 0010bc	e8 00 00 		call	_fopen
	*** 0010bf	83 c4 04 		add	sp,4
	*** 0010c2	89 46 fc 		mov	WORD PTR [bp-4],ax	;lImageFile
	*** 0010c5	0b c0 			or	ax,ax
	*** 0010c7	75 03 			jne	$JCC4295
	*** 0010c9	e9 b8 00 		jmp	$I954
					$JCC4295:
;|*** 
;|***         while( !feof(lImageFile)  &&  !done  &&  (iterations++ < 512) ) {
; Line 1518
	*** 0010cc	8b d8 			mov	bx,ax
	*** 0010ce	f6 47 06 10 		test	BYTE PTR [bx+6],16	;0010H
	*** 0010d2	74 03 			je	$JCC4306
	*** 0010d4	e9 a4 00 		jmp	$FB957
					$JCC4306:
					$FC956:
	*** 0010d7	83 7e fa 00 		cmp	WORD PTR [bp-6],0	;done
	*** 0010db	74 03 			je	$JCC4315
	*** 0010dd	e9 9b 00 		jmp	$FB957
					$JCC4315:
	*** 0010e0	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;iterations
	*** 0010e3	ff 46 f8 		inc	WORD PTR [bp-8]	;iterations
	*** 0010e6	3d 00 02 		cmp	ax,512	;0200H
	*** 0010e9	7c 03 			jl	$JCC4329
	*** 0010eb	e9 8d 00 		jmp	$FB957
					$JCC4329:
;|*** 
;|***             if( fgetc(lImageFile) == *delim_ptr ) {
; Line 1520
	*** 0010ee	53 			push	bx
	*** 0010ef	e8 00 00 		call	_fgetc
	*** 0010f2	83 c4 02 		add	sp,2
	*** 0010f5	8b c8 			mov	cx,ax
	*** 0010f7	8a 04 			mov	al,BYTE PTR [si]
	*** 0010f9	98 			cbw	
	*** 0010fa	3b c8 			cmp	cx,ax
	*** 0010fc	75 04 			jne	$I958
;|***                 delim_ptr++;
; Line 1521
	*** 0010fe	46 			inc	si
;|***             } else {
; Line 1522
	*** 0010ff	eb 04 			jmp	SHORT $I959
	*** 001101	90 			nop	
					$I958:
;|***                 delim_ptr = delim;
; Line 1523
	*** 001102	8d 76 f0 		lea	si,WORD PTR [bp-16]	;delim
;|***             }
; Line 1524
					$I959:
;|*** 			
;|***             if( delim_ptr == delim_end ) {
; Line 1526
	*** 001105	8d 46 f3 		lea	ax,WORD PTR [bp-13]
	*** 001108	3b f0 			cmp	si,ax
	*** 00110a	75 63 			jne	$L996
;|*** 
;|***                 // Initial delimiter string found, collect data:
;|***                 fseek(lImageFile, align32bit, SEEK_CUR);    // next 32-bit boundary	
; Line 1529
	*** 00110c	6a 01 			push	1
	*** 00110e	6a 00 			push	0
	*** 001110	6a 01 			push	1
	*** 001112	ff 76 fc 		push	WORD PTR [bp-4]	;lImageFile
	*** 001115	e8 00 00 		call	_fseek
	*** 001118	83 c4 08 		add	sp,8
;|*** 		ver_lo = fgetc(lImageFile);                 // Get two bytes (in a DWORD)
; Line 1530
	*** 00111b	ff 76 fc 		push	WORD PTR [bp-4]	;lImageFile
	*** 00111e	e8 00 00 		call	_fgetc
	*** 001121	83 c4 02 		add	sp,2
	*** 001124	89 46 f6 		mov	WORD PTR [bp-10],ax	;align32bit
;|***                 ver_hi = fgetc(lImageFile);					
; Line 1531
	*** 001127	ff 76 fc 		push	WORD PTR [bp-4]	;lImageFile
	*** 00112a	e8 00 00 		call	_fgetc
	*** 00112d	83 c4 02 		add	sp,2
	*** 001130	89 46 f4 		mov	WORD PTR [bp-12],ax	;ver_hi
;|***                 fseek(lImageFile, 2, SEEK_CUR);             // Skip two bytes to next 32-bit boundary
; Line 1532
	*** 001133	6a 01 			push	1
	*** 001135	6a 00 			push	0
	*** 001137	6a 02 			push	2
	*** 001139	ff 76 fc 		push	WORD PTR [bp-4]	;lImageFile
	*** 00113c	e8 00 00 		call	_fseek
	*** 00113f	83 c4 08 		add	sp,8
;|*** 
;|***                 delim_ptr = delim;
; Line 1534
	*** 001142	8d 76 f0 		lea	si,WORD PTR [bp-16]	;delim
	*** 001145	c7 46 fe 03 00 		mov	WORD PTR [bp-2],3	;delim_end
;|*** {
; Line 1497
	*** 00114a	8b 7e fe 		mov	di,WORD PTR [bp-2]	;delim_end
;|*** 
;|*** #define DELIM_LEN 3
;|*** 
;|***     char delim[] = "$@(";		// To change delimiter, modify delim & DELIM_LEN!
;|***     char *delim_ptr = delim;
;|***     char *delim_end = delim + DELIM_LEN;
;|***     int  align32bit = 4 - ( DELIM_LEN % 4 );
;|*** 
;|***     FILE *lImageFile = NULL;	
;|***     int  ver_lo,ver_hi;			
;|***     int  done = 0;			// Loop exit condition, done = 1 denotes version found
;|***     int  iterations = 0;		// Used to limit search length
;|***     int  cnt;					
;|*** 
;|***     lImageFile = fopen( pszFileName, "rb" );
;|*** 
;|***     // Algorithm to search through image for 'delim' (version) 'delim'
;|***     // If successful, sets done = 1.
;|***     if( lImageFile ) {
;|*** 
;|***         while( !feof(lImageFile)  &&  !done  &&  (iterations++ < 512) ) {
;|*** 
;|***             if( fgetc(lImageFile) == *delim_ptr ) {
;|***                 delim_ptr++;
;|***             } else {
;|***                 delim_ptr = delim;
;|***             }
;|*** 			
;|***             if( delim_ptr == delim_end ) {
;|*** 
;|***                 // Initial delimiter string found, collect data:
;|***                 fseek(lImageFile, align32bit, SEEK_CUR);    // next 32-bit boundary	
;|*** 		ver_lo = fgetc(lImageFile);                 // Get two bytes (in a DWORD)
;|***                 ver_hi = fgetc(lImageFile);					
;|***                 fseek(lImageFile, 2, SEEK_CUR);             // Skip two bytes to next 32-bit boundary
;|*** 
;|***                 delim_ptr = delim;
;|***            
;|***                 for( cnt=0; cnt < DELIM_LEN; cnt++) {
; Line 1536
					$F961:
;|***                     if( fgetc(lImageFile) == *delim_ptr ) {
; Line 1537
	*** 00114d	ff 76 fc 		push	WORD PTR [bp-4]	;lImageFile
	*** 001150	e8 00 00 		call	_fgetc
	*** 001153	83 c4 02 		add	sp,2
	*** 001156	8b c8 			mov	cx,ax
	*** 001158	8a 04 			mov	al,BYTE PTR [si]
	*** 00115a	98 			cbw	
	*** 00115b	3b c8 			cmp	cx,ax
	*** 00115d	75 01 			jne	$FC962
;|***                         delim_ptr++;
; Line 1538
	*** 00115f	46 			inc	si
;|***                 for( cnt=0; cnt < DELIM_LEN; cnt++) {
; Line 1536
					$FC962:
	*** 001160	4f 			dec	di
	*** 001161	75 ea 			jne	$F961
;|***                     if( fgetc(lImageFile) == *delim_ptr ) {
;|***                         delim_ptr++;
;|***                     }
;|***                 }
;|*** 
;|***                 if( delim_ptr == delim_end ) {
; Line 1542
	*** 001163	8d 46 f3 		lea	ax,WORD PTR [bp-13]
	*** 001166	3b f0 			cmp	si,ax
	*** 001168	75 05 			jne	$L996
;|***                     done = 1;
; Line 1543
	*** 00116a	c7 46 fa 01 00 		mov	WORD PTR [bp-6],1	;done
					$L996:
;|***                 }
;|***             }
;|***         }
; Line 1546
	*** 00116f	8b 5e fc 		mov	bx,WORD PTR [bp-4]	;lImageFile
	*** 001172	f6 47 06 10 		test	BYTE PTR [bx+6],16	;0010H
	*** 001176	75 03 			jne	$JCC4470
	*** 001178	e9 5c ff 		jmp	$FC956
					$JCC4470:
					$FB957:
;|*** 
;|***         fclose( lImageFile );
; Line 1548
	*** 00117b	ff 76 fc 		push	WORD PTR [bp-4]	;lImageFile
	*** 00117e	e8 00 00 		call	_fclose
	*** 001181	83 c4 02 		add	sp,2
;|***     }
;|*** 
;|***     if (done) {
; Line 1551
					$I954:
	*** 001184	83 7e fa 00 		cmp	WORD PTR [bp-6],0	;done
	*** 001188	74 1a 			je	$I966
;|***         printf("Booting %s compiled with Windows CE Version %d\n", pszFileName, (ver_lo | (ver_hi << 8)) );
; Line 1552
	*** 00118a	8a 66 f4 		mov	ah,BYTE PTR [bp-12]	;ver_hi
	*** 00118d	2a c0 			sub	al,al
	*** 00118f	0b 46 f6 		or	ax,WORD PTR [bp-10]	;align32bit
	*** 001192	50 			push	ax
	*** 001193	ff 76 04 		push	WORD PTR [bp+4]	;pszFileName
	*** 001196	68 00 00 		push	OFFSET DGROUP:$SG967
	*** 001199	e8 00 00 		call	_printf
	*** 00119c	83 c4 06 		add	sp,6
;|***     } else { 
; Line 1553
	*** 00119f	5e 			pop	si
	*** 0011a0	5f 			pop	di
	*** 0011a1	c9 			leave	
	*** 0011a2	c3 			ret	
	*** 0011a3	90 			nop	
					$I966:
;|***         printf("%s: Unknown or old version of bootloader\n", pszFileName);
; Line 1554
	*** 0011a4	ff 76 04 		push	WORD PTR [bp+4]	;pszFileName
	*** 0011a7	68 00 00 		push	OFFSET DGROUP:$SG969
	*** 0011aa	e8 00 00 		call	_printf
	*** 0011ad	83 c4 04 		add	sp,4
;|***     }
;|*** 
;|*** }; Line 1557
	*** 0011b0	5e 			pop	si
	*** 0011b1	5f 			pop	di
	*** 0011b2	c9 			leave	
	*** 0011b3	c3 			ret	

DisplayCEOSVersion	ENDP
_TEXT	ENDS
END
